<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fileformat>
<fileformat>

	<token name="verexpr" attrs="vercond">
		<verexpr token="#DLA#" string="(#VER# #EQ# 7)">DLA</verexpr>
		<verexpr token="#ZTUAC#" string="(#VER# #EQ# 13)">ZTUAC</verexpr>
		<verexpr token="#PC#" string="(#VER# #EQ# 32)">PC</verexpr>
		<verexpr token="#JWE#" string="((#VER# #EQ# 47) #OR# (#VER# #EQ# 39))">JWE</verexpr>
		<verexpr token="#PZ#" string="((#VER# #EQ# 48) #OR# (#VER# #EQ# 50))">PZ all</verexpr>
		<verexpr token="#PZ16#" string="(#VER# #EQ# 50)">PZ 1.6+</verexpr>
		<verexpr token="#JWE2#" string="(#VER# #EQ# 51)">JWE2</verexpr>
		There is a versioning issue introduced by the Biosyn update as the ms2 version has not been incremented immediately
		<verexpr token="#JWE2_BIO#" string="(#VER# #EQ# 52)">JWE2</verexpr>
		<verexpr token="#WAR#" string="(#VER# #EQ# 53)">Warhammer Age of Sigmar - Realms of Ruin</verexpr>
		<verexpr token="#PC2#" string="(#VER# #EQ# 54)">Planet Coaster 2</verexpr>
	</token>

	<token name="global" attrs="vercond access">
		Global Tokens.
		NOTE: These must be listed after the above tokens so that they replace last. For example, `verexpr` uses these tokens.
		<global token="#VER#" string="version" />
	</token>

	<xi:include href="../ovl_base/ovl_base.xml" xmlns:xi="http://www.w3.org/2001/XInclude" xpointer="xpointer(*/*)" />

	<!-- set latest occurence of a version number in a game first so that that is set by the setters -->
	<version id="DLA" version="7" >Disneyland Adventures</version>
	<version id="ZTUAC" version="13" >Zoo Tycoon</version>
	<version id="PC" version="32" >Planet Coaster</version>
	<version id="JWE" version="47 39" >Jurassic World Evolution</version>
	<version id="PZ" version="50 48" >Planet Zoo</version>
	<version id="JWE2" version="52 51" >Jurassic World Evolution 2</version>
	<version id="WAR" version="53" >Warhammer Age of Sigmar - Realms of Ruin</version>
	<version id="PC2" version="54" >Planet Coaster 2</version>

	<basic name="BiosynVersion" integral="true" countable="true">
		An unsigned 32-bit integer.
	</basic>
	
	<basic name="MainVersion" integral="true" countable="true">
		An unsigned 32-bit integer.
	</basic>

	<basic name="BonePointerIndex" integral="true" countable="true">
	</basic>

	<enum name="JWE1Collision" storage="uint64">
		<option value="0" name="LEGACY_DO_NOT_USE" />
		<option value="1" name="Landscape" />
		<option value="2" name="Prop" />
		<option value="4" name="Water" />
		<option value="32" name="Building" />
		<option value="64" name="Rotor" />
		<option value="128" name="Wheel" />
		<option value="256" name="NavMesh" />
		<option value="1024" name="Tree" />
		<option value="2048" name="Fence" />
		<option value="4096" name="Wall" />
		<option value="8192" name="Path" />
		<option value="16384" name="Track" />
		<option value="32768" name="Pylon" />
		<option value="65536" name="Foliage" />
		<option value="131072" name="FlyingVehicleObstacle" />
		<option value="524288" name="Guest" />
		<option value="1048576" name="DinosaurNoCollision" />
		<option value="2097152" name="CarObstacle" />
		<option value="4194304" name="GuestObstacle" />
		<option value="16777216" name="CameraObstacle" />
		<option value="17179869184" name="WaterSplash" />
		<option value="2251799813685248" name="GuestAvoidance" />
		<option value="2251799814733824" name="DinosaurCollisionProxy" />
		<option value="2423508312260608" name="Dinosaur" />
		<option value="4503603922337856" name="AIVehicle" />
		<option value="4675565831323648" name="Debris" />
		<option value="5027426723692546" name="DevelopmentAll" />
		<option value="5027426723692608" name="Vehicle" />
		<option value="6927107939631104" name="DinosaurSelfCollision" />
		<option value="14034625978433600" name="CarBody" />
	</enum>

	<enum name="PcCollision" storage="uint64">
		<option value="0" name="Default" />
		<option value="1" name="Landscape" />
		<option value="2" name="Prop" />
		<option value="4" name="Water" />
		<option value="8" name="Character" />
		<option value="16" name="Projectile" />
		<option value="32" name="Building" />
		<option value="64" name="Track" />
		<option value="128" name="Car_OnTrack" />
		<option value="256" name="Car_OffTrack" />
		<option value="512" name="Vehicle" />
		<option value="1024" name="Wheel" />
		<option value="2048" name="NavMesh" />
		<option value="4096" name="UIElement" />
		<option value="8192" name="Ride" />
		<option value="16384" name="Tree" />
		<option value="32768" name="TrackScenery" />
		<option value="65536" name="Miscreant" />
		<option value="131072" name="FlatRideScenery" />
		<option value="262144" name="DriveableCar" />
		<option value="524288" name="DriveThru" />
	</enum>

	<enum name="PcSurface" storage="ushort">
		<option value="0" name="Landscape" />
		<option value="1" name="Prop" />
		<option value="2" name="Water" />
		<option value="3" name="Character" />
		<option value="4" name="Projectile" />
		<option value="5" name="Building" />
		<option value="6" name="Track" />
		<option value="7" name="Car_OnTrack" />
		<option value="8" name="Car_OffTrack" />
		<option value="9" name="Vehicle" />
		<option value="10" name="Wheel" />
		<option value="11" name="NavMesh" />
		<option value="12" name="UIElement" />
		<option value="13" name="Ride" />
		<option value="14" name="Tree" />
		<option value="15" name="TrackScenery" />
		<option value="16" name="Miscreant" />
		<option value="17" name="FlatRideScenery" />
		<option value="18" name="DriveableCar" />
		<option value="19" name="DriveThru" />
	</enum>

	<enum name="JWE1Surface" storage="uint">
		<option value="0" name="LEGACY_DO_NOT_USE" />
		<option value="1" name="Default" />
		<option value="2" name="LandscapeDefault" />
		<option value="3" name="LandscapeFrictionless" />
		<option value="4" name="LandscapeDirt" />
		<option value="5" name="LandscapeGrass" />
		<option value="6" name="LandscapeIce" />
		<option value="7" name="LandscapeMetal" />
		<option value="8" name="LandscapeMud" />
		<option value="9" name="LandscapePondBottom" />
		<option value="10" name="LandscapeSand" />
		<option value="11" name="LandscapeSnow" />
		<option value="12" name="LandscapeStone" />
		<option value="13" name="LandscapeWood" />
		<option value="14" name="LandscapeWoodHollow" />
		<option value="15" name="LandscapeFoliage" />
		<option value="16" name="Water" />
		<option value="17" name="BuildingBrick" />
		<option value="18" name="BuildingConcrete" />
		<option value="19" name="BuildingGlass" />
		<option value="20" name="BuildingIce" />
		<option value="21" name="BuildingMetal" />
		<option value="22" name="BuildingSnow" />
		<option value="23" name="BuildingWood" />
		<option value="24" name="PropTree" />
		<option value="25" name="PropLeaves" />
		<option value="26" name="PropMetal" />
		<option value="27" name="PropWooden" />
		<option value="28" name="PropPlastic" />
		<option value="29" name="PropStone" />
		<option value="30" name="PropLitter" />
		<option value="31" name="DirtPath" />
		<option value="32" name="CharacterCollidableLimb" />
		<option value="33" name="CharacterNonCollidableLimb" />
		<option value="34" name="CharacterFlying" />
		<option value="35" name="NonCollidableLimb" />
		<option value="36" name="SceneryDefault" />
		<option value="37" name="SceneryTree" />
		<option value="38" name="StructureWall" />
		<option value="39" name="StructureFence" />
		<option value="40" name="StructurePylon" />
		<option value="41" name="StructurePath" />
		<option value="42" name="StructureTrack" />
		<option value="43" name="Gyrosphere" />
		<option value="44" name="CarBody" />
		<option value="45" name="Debris" />
		<option value="46" name="DinosaurLimb" />
	</enum>

	<enum name="RigidBodyFlag" storage="uint">
		<option value="0" name="Static" />
		<option value="1" name="DynamicsAsleep" />
		<option value="2" name="DynamicsAwake" />
	</enum>

	<enum name="MeshFormat" storage="ubyte">
		<option value="0" name="Separate" />
		<option value="1" name="Speedtree32" />
		<option value="2" name="Impostor48" />
	</enum>

<!--Count from the end!!!-->
	<bitfield name="WeightsFlag" storage="ushort">
		<member width="1" pos="0" name="has_weights" type="bool"/>
		<member width="8" pos="1" name="bone_index" type="int"/>
		<member width="7" pos="9" name="mesh_format" type="MeshFormat"/>
	</bitfield>

	<bitfield name="WeightsFlagMalta" storage="ushort">
		<member width="2" pos="0" name="mesh_format" type="MeshFormat"/>
		<member width="1" pos="3" name="has_weights" type="bool"/>
		<member width="8" pos="4" name="bone_index" type="int"/>
	</bitfield>

	<bitfield name="WeightsFlagPC2" storage="ushort">
		<member width="2" pos="0" name="mesh_format" type="MeshFormat"/>
		<member width="1" pos="3" name="material_effects" type="bool">if off: metal turns white, alpha is not used</member>
		<member width="1" pos="4" name="has_weights" type="bool"/>
		<member width="8" pos="5" name="bone_index" type="int"/>
	</bitfield>

	<bitfield name="ModelFlag" storage="uint">
		Determines the data held by a mesh.
		<member width="3" pos="0" name="unk" type="int">?</member>
		<member width="1" pos="3" name="stripify" type="bool">if true, tris are stored as a tri strip</member>
		<member width="1" pos="4" name="weights" type="bool">reserves the last 16 bytes for weights, only uses 4 for indices and weights each</member>may be different in PC
		<member width="1" pos="5" name="repeat tris" type="bool">repeats the tri array 5 times verbatim, usually active with shells</member>
		<member width="3" pos="6" name="num_shells" type="int">amount of rendered shell layers, can differ from the hardcoded amount of repeats of the tris buffer</member>
		<member width="1" pos="9" name="direct_address" type="bool">found on all known PZ flags, on no PC flag (x*16)</member>
<!--		<member width="6" pos="10" name="unused" type="int">not used in PZ or PC as of 2023-10-29</member>-->
	</bitfield>

	<bitfield name="ChunkedModelFlag" storage="uint">
		Determines the data held by a mesh.
		<member width="1" pos="0" name="flat_arrays" type="bool">vecs, weights, uvs if true, interleaved per vertex if false</member>
		so far not sure about these, it is 13 on shell meshes
		<member width="1" pos="2" name="fur_shells" type="bool">active if mesh uses fur shells, may or may not repeat tris</member>
		<member width="1" pos="3" name="fur_shells_2" type="bool">active if mesh uses fur shells, may or may not repeat tris</member>
	</bitfield>

	<bitfield name="ModelFlagZT" storage="uint">
		Determines the data held by a mesh.
		<member width="1" pos="6" name="stripify" type="bool">if true, tris are stored as a tri strip</member>
		<member width="1" pos="9" name="repeat tris" type="bool">repeats the tri array 5 times</member>
	</bitfield>

	<bitfield name="ModelFlagDLA" storage="uint">
		Determines the data held by a mesh.
		<member width="1" pos="1" name="vertex_offset" type="bool">seen in DLA - if false, vertex_offset = -1</member>
		<!-- todo - check if this is stripify, meaning of stripify is different here - currently hacked in MeshData.py triangulate -->
		<!-- pos 2 would also qualify 36 0b100100, 38 0b100110 -->
		<member width="1" pos="5" name="stripify" type="bool">if true, tris are stored as a tri strip</member>
<!--		<member width="1" pos="9" name="repeat tris" type="bool">repeats the tri array 5 times</member>-->
	</bitfield>

	<bitfield name="RenderFlag" storage="ushort">
		Determines how the model is rendered.
		<member width="1" pos="0" name="a" type="bool">?</member>
		<member width="1" pos="1" name="b" type="bool">?</member>
		<member width="1" pos="2" name="c" type="bool">?</member>
		<member width="1" pos="3" name="d" type="bool">?</member>
		<member width="1" pos="4" name="e" type="bool">?</member>
	</bitfield>

	<enum name="CollisionType" storage="uint">
		<option value="0" name="Sphere" />
		<option value="1" name="BoundingBox" />
		<option value="2" name="Capsule" />
		<option value="3" name="Cylinder" />
		<option value="7" name="ConvexHull" />
		<option value="8" name="ConvexHullPC" />
		<option value="10" name="MeshCollision"/>
		<option value="11" name="UnkRhino" >?</option>
	</enum>

	<struct name="Matrix" >
		A generic transformation matrix.
	</struct>

	<struct name="Matrix44" inherit="Matrix" size="64">
		A 4x4 transformation matrix.
		<field name="data" type="float" arr1="4" arr2="4">Stored in OpenGL column-major format.</field>
	</struct>

	<struct name="Matrix33" inherit="Matrix" size="36">
		A 3x3 rotation matrix; M^T M=identity, det(M)=1.
		<field name="data" type="float" arr1="3" arr2="3">Stored in OpenGL column-major format.</field>
	</struct>

	<struct name="AxisAngle" size="16">
		<field name="a" type="float" default="1.0"/>
		<!-- when a = 1.0, x,y,z = 0 -->
		<!-- otherwise x,y,z is a normalized vector -->
		<field name="x" type="float" default="0.0"/>
		<field name="y" type="float" default="0.0"/>
		<field name="z" type="float" default="0.0"/>
	</struct>

	<struct name="StreamDebugger">
		logs stream address to debug log
	</struct>

	<struct name="Bone">
		32 bytes
		<!-- rot first -->
		<field name="loc" type="Vector3" until="47" />
		<field name="scale" type="float" until="47" />
		<field name="rot" type="Vector4" until="47" />
		<!-- loc first -->
		<field name="rot" type="Vector4" since="48" />
		<field name="loc" type="Vector3" since="48" />
		<field name="scale" type="float" since="48" />
	</struct>
	
	<struct name="Ms2Root" inherit="MemStruct">
		root header of the ms2
		48 bytes
		<field name="version" type="MainVersion" >see version tag</field>
		<field name="vertex_buffer_count" type="ushort" >total count of vertex buffers, including streamed buffers</field>
		<field name="mdl2 count" type="ushort"/>
		<field name="name count" type="ushort" >count of names in ms2 buffer0</field>
		<field name="static_buffer_index" type="short" >-1 if there is no vertex buffer at all; else index of static buffers in total buffers</field>
		<field name="zeros" type="uint" arr1="3"/>
		<!-- the following two ptrs are not used in PC -->
		<field name="buffer_infos" type="ArrayPointer" template="BufferInfo" arg="vertex_buffer_count">ms2's static buffer_info or empty (if no buffers)</field>
		<field name="model_infos" type="ArrayPointer" template="ModelInfo" arg="mdl2 count">one for each mdl2</field>
		<!-- already used in DLA -->
		<field name="buffer_pointers" type="ArrayPointer" template="BufferPresence" arg="vertex_buffer_count">links buffers to ms2 dependencies if they are streamed</field>
	</struct>

	<struct name="BufferPresence" inherit="MemStruct">
		<field name="dependency_name" type="Pointer" >in DLA and JWE2, this can be a dependency to a model2stream</field>
	</struct>

	<struct name="MaterialName">
		<field name="name index" type="ushort" until="32">index into ms2 names array</field>
		<field name="name index" type="uint" since="47">index into ms2 names array</field>
		<field name="blend_mode" type="ushort" until="32"/>
		<field name="blend_mode" type="uint" since="47">specifies the blend mode, highly consistent to shader type used
		PZ: 263: {'furshell', 'furpatchworkbaldnessshell', 'furpatchworkshell'}, 6: {'furpatchworkbaldnessfin', 'furfin', 'furpatchworkfin'}, 8: {'animal_whisker'}, 15: {'glass_textured_weather'}
		JWE2: 7: {'dinosaurfur_vanilla_shell'}, 6: {'dinosaurfur_vanilla_fin'}
		</field>
	</struct>

	<struct name="LodInfo">
		DLA, ZTUAC - 16 bytes
		JWE, PZ, JWE2 - 20 bytes
		JWE2 Biosyn - 12 bytes, skips the vert / tris counts
		<field name="full" type="short" until="13" >FFFF</field>
		<field name="half" type="short" until="13" >7F7F</field>
		<field name="lod index" type="ushort" until="13" >increasing</field>
		<field name="distance" type="float" since="32" >usually first lod is 900</field>
		<field name="stream_index" type="ushort" since="32" >matches the buffer index used by this LOD's meshes</field>
		<field name="bone_index" type="ushort" >Last bone that is used by this lod's models; usually decreases with increasing lod index to decimate bones. However: JWE detailobjects - nat_groundcover_searocket_patchy_02 due to dedicated lod nodes</field>
		<field name="first_object_index" type="ushort" >first object for this lod in objects list</field>
		<!-- # apparent repeats, purpose unknown -->
		<field name="first_object_index_1" type="ushort" until="13"/>
		<field name="first_object_index_2" type="ushort" until="13"/>
		<field name="last object index" type="ushort" >not included in interval (python style indexing)</field>
		<field name="vertex count" type="uint" since="32" until="51">sum for objects in lod, duplicated meshes count</field>
		<field name="tri_index_count" type="uint" since="32" until="51" >sum for objects in lod, duplicated meshes count</field>
	</struct>

	<struct name="Object">
		<field name="material index" type="ushort" >index into material name array</field>
		<field name="mesh index" type="ushort" >index into mesh array</field>
	</struct>

	<struct name="MeshData" inherit="MemStruct">
		used for shared functions
		<field name="stream_index" type="uint64" until="32">index into streamed buffers</field>
		<field name="stream_info" type="LookupPointer" template="BufferInfo" since="47">PZ and JWE use a ptr instead</field>
		<field name="some_index" type="uint" until="51">increments somewhat in ZTUAC platypus, apparently unused from JWE onward</field>
		<field name="some_index_2" type="uint" until="51" vercond="!#PC#">?</field>
	</struct>

	<struct name="ChunkedMesh" inherit="MeshData">
		JWE2 after Biosyn update - 48 bytes incl. inheritance
		<field name="chunks_offset" type="uint" >start index into list of verts / tris chunks</field>
		<field name="chunks_count" type="uint" >count of verts / tris chunks</field>
		<field name="tris_count" type="uint" >num triangles in mesh, *3 for byte size</field>
		<field name="vertex_count" type="uint" >num verts in mesh</field>
		<field name="zero" type="uint64" default="0"/>
		<field name="poweroftwo" type="uint">power of 2 increasing with lod index</field>
		<field name="unk_float_0" type="float" >?</field>
		<field name="unk_float_1" type="float" >?</field>
		<field name="flag" type="ChunkedModelFlag">seen 1 or 13</field>
	</struct>

	<struct name="NewMeshData" inherit="MeshData">
		PZ, JWE2 - 64 bytes incl. inheritance
		<field name="vertex_count" type="uint" />
		<field name="tri_index_count" type="uint" >number of index entries in the triangle index list; (not: number of triangles, byte count of tri buffer)</field>
		<field name="zero1" type="uint">always zero</field>
		<field name="poweroftwo" type="uint">power of 2 increasing with lod index</field>
		<field name="vertex offset" type="uint" >in bytes</field>
		<field name="size of vertex" type="uint" default="48"/>
		<field name="tri offset" type="uint">in bytes</field>
		<field name="zero2" type="uint">always zero</field>
		<field name="unk_float_0" type="float" >?</field>
		<field name="unk_float_1" type="float" >?</field>
		<field name="zero3" type="uint">always zero</field>
		<field name="flag" type="ModelFlag">bitfield, determines vertex format</field>
	</struct>

	<struct name="PcMeshData" inherit="MeshData">
		72 bytes total
		<field name="tri_index_count a" type="uint" >repeat</field>
		<field name="vertex_count" type="uint" />
		<field name="tri offset" type="uint">x*16 = offset</field>
		<field name="tri_index_count" type="uint" >number of index entries in the triangle index list; (not: number of triangles, byte count of tri buffer)</field>
		<field name="vertex offset" type="uint" >x*16 = offset</field>
		<field name="weights offset" type="uint">x*16 = offset</field>
		<field name="uv offset" type="uint" >x*16 = offset</field>
		<field name="uv offset 2" type="uint" >x*16 = offset</field>
		<field name="vertex color offset" type="uint">x*16 = offset</field>
		<field name="vertex offset within lod" type="uint" >cumulative count of vertices in mesh's lod before this mesh</field>
		<field name="poweroftwo" type="uint">power of 2 increasing with lod index</field>
		<field name="zero b" type="uint" default="0"/>
		<field name="unk_float_0" type="float" >?</field>
		<field name="flag" type="ModelFlag">bitfield</field>
		<field name="zero c" type="uint" default="0"/> <!-- this may be padding that might not be on the end of an array? -->
	</struct>

	<struct name="ZtMeshData" inherit="MeshData">
		64 bytes total, same layout for DLA and ZTUAC
		<field name="tri_index_count" type="uint" >repeat</field>
		<field name="vertex_count" type="uint" />
		<field name="tri_info_offset" type="uint">stores count, -1 as ints</field>
		<field name="vert info offset" type="uint" >stores count, -1 as ints</field>
		<field name="known ff 0" type="int"/>
		<field name="tri offset" type="uint"/>
		<field name="uv offset" type="uint" >variable dtype, can include vertices too</field>
		<field name="vertex offset" type="uint">if present, blocks of 24 bytes</field>
		<field name="unk_index" type="short">often -1, but not always</field>
		<field name="one 0" type="ushort"/>
		<field name="one 1" type="ushort" >?</field>
		<field name="poweroftwo" type="ushort"/>
		<field name="flag" type="ModelFlagDLA" until="7">bitfield</field>
		<field name="flag" type="ModelFlagZT" since="13">bitfield</field>
		<field name="zero uac" type="uint" >always zero</field>
	</struct>

	<struct name="MeshDataWrap" inherit="MemStruct">
		<field name="mesh" type="ChunkedMesh" since="52"/>
		<field name="mesh" type="NewMeshData" since="47" until="51"/>
		<field name="mesh" type="PcMeshData" vercond="#PC#"/>
		<field name="mesh" type="ZtMeshData" vercond="#ZTUAC#"/>
		<field name="mesh" type="ZtMeshData" vercond="#DLA#"/>
	</struct>

	<struct name="ZTPreBones">
		<field name="zeros" type="uint64" arr1="2" />
		<field name="unks" type="uint" arr1="8" />
		<field name="unks2" type="uint" arr1="10" />
		<field name="floats" type="float" arr1="4" />
		<field name="unks3" type="uint" arr1="2" />
	</struct>

	<struct name="DLAPreBones">
		<field name="unk" type="ubyte" arr1="120" />
	</struct>

	<struct name="FloatsY">
		<field name="floats" type="float" arr1="8" />
		<field name="index" type="uint" />
	</struct>

	<struct name="Model">
		<field name="start ref" type="Empty"/>
		<field name="materials" type="MaterialName" arr1="#ARG#\num_materials" >name pointers for each material</field>
		<field name="lods" type="LodInfo" arr1="#ARG#\num_lods" >lod info for each level, only present if models are present (despite the count sometimes saying otherwise!)</field>
		<field name="objects" type="Object" arr1="#ARG#\num_objects" >instantiate the meshes with materials</field>
		<field name="mesh aligner" type="PadAlign" template="start ref" arg="8" until="32"/>
		<field name="meshes" type="MeshDataWrap" arr1="#ARG#\num_meshes" >mesh data blocks for this model</field>
		<field name="pre bones" type="ZTPreBones" vercond="#ZTUAC#" cond="#ARG# \ last_count">?</field>
		<field name="pre bones" type="DLAPreBones" vercond="#DLA#" cond="#ARG# \ last_count">?</field>
		<field name="floatsy" type="FloatsY" arr1="#ARG#\render flag" until="32" /> <!-- see if it is a flag for ztuac too, so might be totally wrong here</field> -->
		<!-- alignment here is handled by py code, seems to depend on whether a bone info follows -->
	</struct>

	<struct name="ZtTriBlockInfo" >
		8 bytes total
		<field name="tri_index_count" type="uint" />
		<field name="a" type="short" />
		<field name="unk_index" type="short" />
	</struct>

	<struct name="ZtVertBlockInfo" >
		16 bytes total
		<field name="vertex_count" type="uint" />
		<field name="flags" type="ubyte" arr1="8" />
		<field name="zero" type="uint" />
	</struct>

	<struct name="InfoZTMemPool" >
		<field name="unk count" type="ushort" >?</field>
		<field name="unks" type="ushort" arr1="unk count" arr2="2" >?</field>
	</struct>

	<struct name="StreamsZTHeader" >
		266 bytes ?
		very end of buffer 0 after the names list
		<field name="weird padding" type="SmartPadding">sometimes 00 byte</field>
		<field name="unks" type="InfoZTMemPool" arr1="#ARG# \ static_buffer_index" >?</field>
	</struct>

	<struct name="Buffer0" >
		<field name="name hashes" type="uint" arr1="#ARG#\name count" >djb2 hashes</field>
		<field name="names" type="ZString" arr1="#ARG#\name count" >names</field>
		<field name="names padding" type="PadAlign" template="names" arg="4" since="50"/>
		<field name="zt streams header" type="StreamsZTHeader" until="13" arg="#ARG#" />
	</struct>

	<struct name="BufferInfo" >
		Fragment data describing a MS2 buffer giving the size of the whole vertex and tri buffer.
		ZTUAC, DLA: 64 bytes verts, tris, uvs (incl. verts sometimes)
		PC: 32 bytes, lumps all data (pos, uv, weights, tris) into verts_size
		JWE: 48 bytes
		PZ old: 32 bytes?
		PZ1.6+ and JWE2: 56 bytes
		JWE2 Biosyn: 88 bytes, with 4 values, order of arrays in buffer is verts, tris, tri_chunks, vert_chunks

		<!-- JWE and PC, 16 bytes of 00 padding -->
		<field name="u0" type="uint64" since="32" until="47" />
		<field name="u1" type="uint64" since="32" until="47" />

		<field name="tri_chunks_size" type="uint64" since="52"/>
		<field name="tri_chunks_ptr" type="uint64" since="52"/>
		<field name="vert_chunks_size" type="uint64" since="52"/>
		<field name="vert_chunks_ptr" type="uint64" since="52"/>

		<field name="verts_size" type="uint64"/>
		<field name="verts_ptr" type="uint64"/>
		<!-- PC ends here -->
		<!-- PZ+, another 8 empty bytes -->
		<field name="u3" type="uint64" since="48" until="52"/>
		<!-- on all games except PC -->

		<!-- at offset 56 in JWE2 -->
		<field name="tris_size" type="uint64" vercond="!#PC#"/>
		<field name="tris_ptr" type="uint64" vercond="!#PC#"/>
		<!-- PZ+, another 16 empty bytes -->
		<field name="u5" type="uint64" since="48" until="52"/>
		<field name="u6" type="uint64" since="48" until="52"/>
		<!-- alternative end, ZTUAC style -->
		<field name="u5" type="uint64" until="13" />
		<field name="uvs_size" type="uint64" until="13" >from start of tris buffer</field>
		<field name="u6" type="uint64" until="13" />
		<field name="u7" type="uint64" until="13" />
	</struct>

	<struct name="ModelInfo" inherit="MemStruct">
		Describes one model, corresponding to a .mdl2 file
		JWE2 - 192 bytes
		JWE2 Biosyn - 160 bytes
		<field name="unk dla" type="uint64" until="7">??</field>
		<field name="bounds min" type="Vector3">the smallest coordinates across all axes</field>
		<field name="precision" type="float" since="47" until="51">related to the inverse of pack_base</field>
		<field name="bounds max" type="Vector3">the biggest coordinates across all axes</field>
		<field name="pack_base" type="float" since="47" until="51">scale: pack_base / 512, also added as offset</field>
		<field name="center" type="Vector3">cog? medium of bounds?</field>
		<field name="radius" type="float" >probably from center to max</field>
		<field name="num_lods_2" type="uint64" since="48" until="51">seen 6 or 1, matches lod count</field>
		<field name="zero" type="uint64" since="48" until="51">zero</field>
		<field name="bounds min repeat" type="Vector3" since="32">verbatim repeat</field>
		<field name="bounds max repeat" type="Vector3" since="32">verbatim repeat</field>
<!--		array counts-->
		<field name="num_materials" type="ushort"/>
		<field name="num_lods" type="ushort"/>
		<field name="num_objects" type="ushort"/>
		<field name="num_meshes" type="ushort"/>
		<field name="last_count" type="ushort">?</field>
		<field name="render_flag" type="RenderFlag">this has influence on whether newly added shells draw correctly; for PZ usually 4, except for furry animals; ZT african ele female</field>
		<field name="unks" type="ushort" arr1="7">?</field>
		<field name="pad" type="ushort" arr1="3" > </field>

		<field name="materials" type="ArrayPointer" template="MaterialName" arg="num_materials"/>
		<field name="lods" type="ArrayPointer" template="LodInfo" arg="num_lods"/>
		<field name="objects" type="ArrayPointer" template="Object" arg="num_objects"/>
		<field name="meshes" type="ArrayPointer" template="MeshDataWrap" arg="num_meshes"/>
		<field name="first_model" type="Pointer">points to the start of this ModelInfo's model, usually starts at materials
			stays the same for successive mdl2s in the same model; or points to nil if no models are present</field>

		<field name="zeros" type="uint64" arr1="4" vercond="#ZTUAC#"/>
		<field name="zeros" type="uint64" arr1="2" vercond="#DLA#"/>
		<field name="increment flag" type="uint64">used to increment skeleton index</field>
		<field name="zero 0" type="uint64" vercond="!#DLA#"/>
		<field name="zero 1" type="uint64" vercond="!#PC#"/>
		<field name="zero 2" type="uint64" since="47" until="51"/>
	</struct>

	<struct name="ModelReader">
		This reads and assigns models to each model_info that is passed to it
	</struct>

    <struct name="ModelstreamHeader" inherit="MemStruct">
		JWE, PZ, PC: 8 bytes
        JWE2, PC2: 16 bytes
		<field name="zero" type="uint64" default="0" optional="True"/>
		<field name="lod_index" type="uint64" since="52"/>
    </struct>

	<struct name="Ms2InfoHeader">
		Custom header struct
		<field name="biosyn" type="BiosynVersion" default="1"/>
		<field name="bone_info_size" type="uint"/>
		<field name="num_streams" type="uint"/>
		<field name="info" type="Ms2Root"/>
		<field name="buffer_pointers" type="BufferPresence" arr1="info \ vertex_buffer_count" since="7">used since DLA</field>
		<field name="mdl2 names" type="ZString" arr1="info \ mdl2_count"/>
		<field name="modelstream_names" type="ZString" arr1="num_streams" />
		<field name="buffer 0" type="Buffer0" arg="info" />
<!--		corresponds to PC buffer 1-->
		<field name="buffer_infos" type="BufferInfo" arr1="info \ vertex_buffer_count" />
		<field name="model_infos" type="ModelInfo" arr1="info \ mdl2_count"/>
		<!-- models and bone infos follow, either separate (new) or interleaved for each modelinfo (old) -->
		<field name="models_reader" type="ModelReader" arg="#SELF#" >handles interleaved (old) or separate (new) styles for models and bone infos</field>
		<!-- many ZTUAC models have a big undecoded array of uints here -->
		<!-- the vertex and face data buffers follow -->
	</struct>

	<struct name="TriChunk" >
		JWE2 Biosyn, PC2: 64 bytes
		<field name="bounds" type="hfloat" arr1="3" arr2="2" since="54">-x, +x, -y, +y, -z, +z</field>
		<field name="bounds min" type="Vector3" until="53">the smallest coordinates across all axes, min of unpacked vert coords if loc is 0,0,0</field>
		<field name="material_index" type="ushort"> 0, 1, 2</field>
		<field name="tris_count" type="ushort"/>
		<field name="bounds max" type="Vector3" until="53">the biggest coordinates across all axes, max of unpacked vert coords if loc is 0,0,0</field>
		<field name="tris_index" type="uint" since="54">index into tris buffer of this mesh, starts at 0 for mesh</field>
		<field name="value_min" type="uint" since="54">minimal vertex value used in tri indices</field>
		<field name="tris_offset" type="uint">bytes into whole tris buffer, as tris use ubyte</field>
		<field name="zero" type="uint" default="0" since="54"/>
		<field name="loc" type="Vector3">can be 0,0,0, no obvious range, not always within range of bounds</field>
		<field name="rot" type="AxisAngle">can be 1, 0, 0, 0; w always in range -1, +1</field>
		<field name="shell_index" type="ushort"> 0, 1, 2 - increments per shell layer</field>
		<field name="shell_count" type="ushort"> 0 or 3 in theri</field>
	</struct>
	
	<struct name="VertChunk" >
		JWE2 Biosyn: 16 bytes
		<field name="precision" type="float" >apparently also used for scaling the mesh: pack_base / 512 / 2048 = scale</field>
		<field name="pack_base" type="float" >the usual mesh scale: pack_base / 512, also added as offset during vertex packing</field>
		<field name="vertex_offset" type="uint" >byte offset from start of vert buffer in bytes</field>
		<field name="vertex_count" type="ubyte"/>
		<field name="weights_flag" type="WeightsFlag" until="51">determines if weights are used by this chunk</field>
		<field name="weights_flag" type="WeightsFlagMalta" since="52" until="53">determines if weights are used by this chunk</field>
		<field name="weights_flag" type="WeightsFlagPC2" since="54">determines if weights are used by this chunk</field>
		<field name="zero" type="ubyte"/> <!-- always -->
	</struct>

	<struct name="MinusPadding">
		Used in PC
		<field name="indices" type="short" arr1="#ARG#" default="-1"/>
		<field name="padding" type="byte" arr1="(16 - ((#ARG# * 2) % 16)) % 16" >0</field>
	</struct>

	<struct name="ZerosPadding">
		1 bit per bone, padded to 8 bytes, all 00
		<field name="padding 0" type="uint64" cond="0 #LT# #ARG#"/>
		<field name="padding 1" type="uint64" cond="64 #LT# #ARG#">128 still has 16 bytes</field>
		<field name="padding 2" type="uint64" cond="128 #LT# #ARG#">129 is the first with 24 bytes</field>
	</struct>

	<struct name="AbstractPointer" abstract="true">
		forward pointing, of varying size
	</struct>

	<struct name="BonePointer" inherit="AbstractPointer">
<!--		<field name="index" type="ubyte" until="52">index into bones</field>-->
<!--		<field name="index" type="ushort" since="53">index into bones</field>-->
		<field name="index" type="BonePointerIndex" default="-1">index into bones</field>
	</struct>

	<struct name="RotationRange">
		tentative interpretation
		<field name="min" type="float"/>
		<field name="max" type="float"/>
	</struct>

	<struct name="IKEntryOld">
		36 bytes
		<field name="name" type="ushort" >index into name buffer</field>
		<field name="index" type="ushort" >unk</field>
		<field name="parent" type="ushort" >bone</field>
		<field name="child" type="ushort" >bone</field>
		<field name="length" type="ushort" default="2" >count of controlled bones in chain</field>
		<field name="parent_again" type="ushort" >bone</field>
		<field name="floats" type="float" arr1="6">some at least</field>
	</struct>

	<struct name="IKEntry">
		60 bytes
		<field name="child" type="BonePointer"/>
		<field name="parent" type="BonePointer"/>
		<field name="unk0" type="ushort" default="0"/>
		<field name="matrix" type="Matrix33" >no clue what space this is in, defines the orientation for the yaw and pitch ranges
		probably relative to the bone</field>
		<field name="yaw" type="RotationRange">degrees</field>
		<field name="pitch" type="RotationRange">degrees</field>
		<field name="unk1" type="uint" default="1"/>
	</struct>

	<struct name="IKTarget">
		2 bytes
		<field name="ik_blend" type="BonePointer"/>
		<field name="ik_end" type="BonePointer"/>
	</struct>

	<struct name="IKInfo">
		<field name="weird padding" type="SmartPadding" until="13" >needed for ZTUAC</field>
<!--		<field name="zeros start" type="ubyte" until="13" arr1="6">guess for ZTUAC rhino, wrong for afr ele child</field>-->
		<field name="ik_count" type="uint64"/>
		<field name="ik_ptr" type="uint64"/>
		<field name="ik_targets_count" type="uint64" since="48"/>
		<field name="ik_targets_ptr" type="uint64" since="48"/>
		<field name="ik ref" type="Empty"/>
		<field name="ik_list" type="IKEntryOld" arr1="ik_count" until="13"/>
		<field name="ik_list" type="IKEntry" arr1="ik_count" since="32"/>
		<field name="padding 0" type="PadAlign" template="ik ref" arg="8"/>
		<field name="ik_targets" type="IKTarget" arr1="ik_targets_count" since="50"/>
		<field name="padding 1" type="PadAlign" template="ik ref" arg="8" since="50"/>
	</struct>

	<struct name="JointTransform">
		Describes a joint in armature space.
		<field name="rot" type="Matrix33" >the rotation of the joint, inverted</field>
		<field name="loc" type="Vector3" >the location of the joint</field>
	</struct>

	<struct name="RigidBody">
		<field name="flag" type="RigidBodyFlag"/>
		<field name="loc" type="Vector3" >center of mass - relative to joint</field>
		<field name="mass" type="float">mass of joint or object</field>
		<field name="air_resistance_x" type="float"/>
		<field name="unk 1" type="float">2.0 in unk1 makes the object not to stop ever, it is breakdancing</field>
		<field name="unk 2" type="float">Related to Bounciness</field>
		<field name="air_resistance_y" type="float"/>
		<field name="unk 4" type="float">?</field>
		<field name="air_resistance_z" type="float"/>
	</struct>

	<struct name="JointPointer" inherit="AbstractPointer">
		<field name="index" type="ushort" >index into joint_infos</field>
	</struct>

	<struct name="Constraint">
		<field name="parent" type="JointPointer"/>
		<field name="child" type="JointPointer"/>
		<field name="loc" type="Vector3" >the location of the child joint</field>
	</struct>

	<struct name="BallConstraint" inherit="Constraint">
		fPhysicsBallJoint
		used in JWE Pteranodon
		no longer used in PZ, JWE2
	</struct>

	<struct name="HingeConstraint" inherit="Constraint">
		fPhysicsHingeJoint
		used in JWE dinos
		no longer used in PZ, JWE2
		<field name="direction" type="Vector3" >normalized direction of Z axis in blender</field>
		<!-- these are LE - GE 0, unlike the limits in RagdollConstraint -->
		<!-- JWE1 nasuto has these, but inverted (due to mirroring?) on X (blender assumes Z for hinge) -->
		<field name="limits" type="RotationRange" >radians</field>
	</struct>

	<struct name="RagdollConstraint" inherit="Constraint">
		fPhysicsRagdollJoint
		vec_a and rot row 0 seem to be identical (tested on JWE1, JWE2, PZ)
		sometimes correspond to the negated child joint rot row0
		<field name="vec_a" type="Vector3" >normed, matches first row of rot</field>
		<!-- row 2 can match child joint rot row 1 -->
		<field name="rot" type="Matrix33" >all 3 rows are orthogonal to one another</field>
		<field name="vec_b" type="Vector3" >normed, and orthogonal to vec_a</field>
		<!-- tolerance around the rotation axes -->
		<field name="x" type="RotationRange" >radians</field>
		<field name="y" type="RotationRange" >radians</field>
		<field name="z" type="RotationRange" >radians</field>
		<!-- apparently a rotation margin under which simulation is allowed to stop -->
		<!-- unlike x, y, z above, this is directional, with min negative -->
		<field name="plasticity" type="RotationRange" >radians</field>
	</struct>

	<struct name="Sphere">
		<field name="center" type="Vector3" >center of the sphere</field>
		<field name="radius" type="float" >radius around the center</field>
		<field name="zero" type="uint" >might be float 0.0</field>
		<field name="zeros2" type="uint" vercond="#PC#" >probably padding</field>
	</struct>

	<struct name="BoundingBox">
		<field name="rotation" type="Matrix33"/>
		<field name="center" type="Vector3" >center of the box</field>
		<field name="extent" type="Vector3" >total width</field>
		<field name="zeros" type="uint" arr1="3" vercond="#PC#" >probably padding</field>
	</struct>

	<struct name="Capsule">
		<field name="offset" type="Vector3" >relative to the armature, ie. not in bone space</field>
		<field name="direction" type="Vector3" >normalized</field>
		<field name="radius" type="float" >radius of the caps</field>
		<field name="extent" type="float" >distance between the center points of the capsule caps, total extent is 2 * radius + extent</field>
		<field name="zero" type="uint" >apparently unused</field>
		<field name="zeros2" type="uint" vercond="#PC#" >probably padding</field>
	</struct>

	<struct name="Cylinder" inherit="Capsule">
		identical data to capsule, just imported differently
	</struct>

	<struct name="ConvexHull">
		<field name="vertex count" type="uint"/>
		<field name="rotation" type="Matrix33"/>
		<field name="offset" type="Vector3" >center of the box</field>
		<field name="zeros" type="uint" arr1="5" vercond="#PC#" >probably padding</field>
		<field name="zeros" type="uint" arr1="2" since="48" >probably padding</field>
	</struct>

	<struct name="MeshCollisionIndex">
		<field name="index" type="ubyte" >increases, starting at 1</field>
		<field name="a" type="ubyte" default="240">?</field>
		<field name="b" type="ubyte" default="237">?</field>
		<field name="c" type="ubyte" default="254">?</field>
	</struct>

	<struct name="MeshCollisionChunk">
		<field name="a" type="short" arr1="24">?</field>
		<field name="tri_indices" type="short" arr1="8">start indices of a group of 16 tris;incrementing by 16 from 0, or if around -32769: incrementing by 1, mostly</field>
		<field name="min_of_indices" type="short" >usually, but not always the first tri index; 0 if tri_indices are negative</field>
		<field name="num_used_tri_slots" type="ubyte" >counts how many slots in tri_indices are used, others are 0</field>
		<field name="salt_index" type="ubyte" >likely</field>
		<field name="consts" type="uint" arr1="3" default="2954754766">always 2954754766?</field>
	</struct>

	<struct name="MeshCollisionOptimizer">
		<field name="bounds min repeat" type="Vector3" >verbatim</field>
		<field name="bounds max repeat" type="Vector3" >verbatim</field>
		<field name="tri flags count" type="uint" >seems to repeat tri_count</field>
		<field name="chunks_count" type="ushort"/>
		<field name="some_index" type="ushort">seen 272 in JWE2</field>
		<field name="zeros" type="ushort" arr1="8" >seen 0 in JWE2</field>
		<field name="chunks" type="MeshCollisionChunk" arr1="chunks_count"/>
		<field name="tris_salt" type="uint" arr1="4" >usually zero, nonzero in JWE2 dev footplant, [1] used as salt for tri indices</field>
	</struct>

	<struct name="MeshCollision">
		JWE2: 188 bytes
		<field name="rotation" type="Matrix33"/>
		<field name="offset" type="Vector3" >offset of mesh</field>
		<field name="indices" type="MeshCollisionIndex" arr1="3" >seems to be constant</field>
		<field name="unk2" type="uint" arr1="3" vercond="#PC#">found in PC FR_GrandCarousel</field>
		<field name="vertex count" type="uint64"/>
		<field name="tri count" type="uint64"/>
		<field name="bounds min" type="Vector3">the smallest coordinates across all axes</field>
		<field name="bounds max" type="Vector3">the biggest coordinates across all axes</field>
		<field name="flag 0" type="uint64" default="1"/>
		<field name="flag 1" type="uint64" default="1"/>
		<field name="is_optimized" type="uint64">seen 1 eg PZ widgetball_test_, or 0 in JWE2 characterscale and PZ CM_Common_Roofs</field>
		<field name="zeros 1" type="uint64" arr1="3"/>
		<field name="tris switch" type="uint64" />
		<field name="ff" type="int" default="-1"/>
		<field name="zeros 2" type="int" arr1="7"/>
<!--		<field name="data" type="MeshCollisionData" abstract="true" arg="#SELF#"/>-->
	</struct>

	<struct name="HitCheck">
		JWE2: 20 bytes excluding collider
		<field name="dtype" type="CollisionType"/>
		<field name="align" type="uint" since="48" default="0"/>
		<field name="ClassificationName" type="PcCollision" until="32"/>
		<!-- todo one of these may be an index into the classification group -->
		<field name="SurfaceName" type="PcSurface" until="32"/>
		<field name="SurfaceName2" type="PcSurface" until="32"/>
		<field name="ClassificationName" type="JWE1Collision" since="47" until="47"/>
		<field name="SurfaceName" type="JWE1Surface" since="47" until="47"/>
		<field name="ClassificationName" type="OffsetString" arg="context \ joint_names" since="48">from physicsskeleton.specdef</field>
		<field name="SurfaceName" type="OffsetString" arg="context \ joint_names" since="48"/>
		<field name="zero_extra_pc" type="uint" until="32">?</field>
		<field name="name" type="OffsetString" arg="context \ joint_names"/>

		<field name="collider" type="Sphere" cond="dtype == 0" />
		<field name="collider" type="BoundingBox" cond="dtype == 1" />
		<field name="collider" type="Capsule" cond="dtype == 2" />
		<field name="collider" type="Cylinder" cond="dtype == 3" />
		<field name="collider" type="ConvexHull" cond="dtype == 7" />
		<field name="collider" type="ConvexHull" cond="dtype == 8" />
		<field name="collider" type="MeshCollision" cond="dtype == 10" />
		<field name="zero_extra_zt" type="uint" vercond="#ZTUAC#">?</field>
	</struct>

	<struct name="JointInfo">
		#ARG# is the names buffer
		PC: 40 bytes
		<field name="eleven" type="uint" default="11"/>
		<field name="ff_1" type="int" default="-1" until="32"/>
		<field name="ff_2" type="int" default="-1" until="32"/>
		<field name="ff_3" type="int" default="536870911" until="32"/>
		<field name="ff_4" type="int" default="-5570646" until="32"/>
		<!-- the following defaults are all the same in PZ and JWE2 as of 2022-10-14 -->
		<field name="zero_0" type="int" default="0" since="47"/>
		<field name="zero_1" type="int" default="0" since="47"/>
		<field name="minus_1" type="int" default="-1" since="47"/>
		<field name="name" type="OffsetString" arg="context \ joint_names"/>
		<field name="hitcheck count" type="uint"/>
		<field name="zero_2_a" type="int" until="32"/>
		<field name="zero_2" type="uint64" default="0"/>
		<!-- deferred to coherent arrays up to PC -->
		<field name="hitcheck_pointers" type="uint64" arr1="hitcheck count" until="32" abstract="True"/>
		<field name="hitcheck_pointers" type="uint64" arr1="hitcheck count" since="47"/> <!-- 8 bytes of zeros per hitcheck -->
		<field name="hitchecks" type="HitCheck" arr1="hitcheck count" arg="#ARG#" until="32" abstract="True"/>
		<field name="hitchecks" type="HitCheck" arr1="hitcheck count" arg="#ARG#" since="47"/>
	</struct>

	<struct name="HitcheckReader">
		This reads and assigns hitchecks to each jointinfo that is passed to it
	</struct>

	<struct name="HitcheckPointerReader">
	</struct>

	<struct name="JointData">
		probably something like ZerosPadding, but does not map to bone count
		joint_pad_size: {0: {1, 3, 10, 12, 17, 26}, 8: {2, 4, 6, 8, 9, 11, 43, 13, 15, 22}, 16: {5, 14, 7}}
		<field name="start_pc" type="SmartPadding" arg="8" vercond="#PC#">seemingly additional alignment, unsure about the rule</field>
		<field name="before_dla_0" type="uint64" until="7"/>
		<field name="before_dla_1" type="uint64" until="7"/>
		<field name="joint_count" type="uint" >repeat</field>
		<field name="num_ball_constraints" type="uint"/>
		<field name="num_hinge_constraints" type="uint"/>
		<field name="num_ragdoll_constraints" type="uint"/>
		<field name="zero 0" type="uint" until="32"/>
		<field name="zero 1" type="uint" since="13" until="32"/>
		<field name="namespace length" type="uint" >size of the name buffer below, including trailing zeros</field>
		<field name="zeros 0" type="uint" arr1="5" >0s</field>
		<field name="pc count" type="uint" >0 or 1</field>
		<field name="zeros 1" type="uint" arr1="7">0s</field>
		<field name="extra zeros 2" type="uint" arr1="4" since="13" until="32">0s</field>
		<field name="one_0" type="uint64" since="13" default="1"/>
		<field name="one_1" type="uint64" since="13" default="1"/>
		<field name="bone count" type="uint" >matches bone count from bone info</field>
		<field name="root_joint_index" type="uint"/>
		<field name="zeros 2" type="uint" arr1="4">usually 0s</field>
		<field name="zeros 3" type="uint" until="7" >usually 0s</field>
		<field name="names_ref" type="Empty"/>
		<field name="joint_transforms" type="JointTransform" arr1="joint_count" >corresponds to bone transforms</field>

		<field name="rigid_body_pointers" type="uint64" arr1="joint_count" since="47"/>
		<field name="rigid_body_list" type="RigidBody" arr1="joint_count" since="47"/>
		<field name="ball_constraints" type="BallConstraint" arr1="num_ball_constraints" since="47"/>
		<field name="hinge_constraints" type="HingeConstraint" arr1="num_hinge_constraints" since="47"/>
		<field name="ragdoll_constraints" type="RagdollConstraint" arr1="num_ragdoll_constraints" since="47"/>

		<field name="joint_infos" type="JointInfo" arr1="joint_count" until="32">without hitchecks, which are added later</field>
		<field name="pc floats" type="float" arr1="pc count" arr2="10" until="32">sometimes an array of floats</field>

		<!--<field name="names_ref_pc" type="Empty"/>-->
		<field name="joint_to_bone" type="int" arr1="joint_count" >index into bone info bones for each joint; bone that the joint is attached to</field>
		<field name="bone_to_joint" type="int" arr1="bone count" >the inverse of the above; for each bone info bone, index of the corresponding joint or -1 if no joint</field>
		<field name="joint_names" type="ZStringBuffer" arg="namespace length"/>
		<field name="JointNamesPadding" type="PadAlign" template="names_ref" arg="8"/>
		<!-- causes no harm but not 100% enough -->
		<field name="hitcheck_pointer_reader" type="HitcheckPointerReader" arg="#SELF#" until="32">8 bytes per hc</field>
		<!-- nope -->
		<!--<field name="hitcheck_pointer_padding" type="PadAlign" template="names_ref" arg="16" until="32"/>-->

		<field name="after_names" type="SmartPadding" until="32" arg="8">
			this seems to be always multiples of 8 bytes
			fails on PC SP_Scarecrow, because its first hitcheck has collision type 0</field>
		<field name="hitcheck_reader" type="HitcheckReader" arg="#SELF#" until="32">old style - for each joint, read the hitchecks</field>
		<field name="joint_infos" type="JointInfo" arr1="joint_count" arg="joint_names" since="47">new style - includes name offset, some flags and the hitchecks</field>
	</struct>

	<struct name="BoneInfo">
		# 858 in DLA c_cl_thread_.ms2
		<field name="name count" type="uint"/>
		<field name="z0" type="ushort" >?</field>
		<field name="inv_names_count" type="ushort"/>
		<field name="bone_limits" type="BonePointer" arr1="2" since="32" until="52"/>
		<field name="zero 0" type="short" default="0" since="32" until="52"/>
		<field name="unknown0c" type="uint" since="32"/>
		<field name="unk count" type="uint" default="4">almost always 4, 1 for male african lion</field>
		<field name="unk unused" type="uint"  until="52"/>
		<field name="war_a" type="ushort" since="53">?</field>
		<field name="bone_limits" type="BonePointer" arr1="2" since="53"/>
		<field name="war_b" type="ushort" since="53">?</field>
		<field name="bind matrix count" type="uint64"/>
		<field name="zeros" type="uint64" arr1="2"/>
		<field name="inv_data_count" type="uint64">if inv_names_count = 1, also 1 for DLA</field>
		<field name="bone count" type="uint64"/>
		<field name="unknown40" type="uint64"/>
		<field name="parents count" type="uint64"/>
		<field name="extra zero" type="uint64" vercond="!(#PC# #OR# #JWE#)">not PC, JWE</field>
		<field name="enum count" type="uint64"/>
		<field name="unknown58" type="uint64" >usually zero</field>
		<field name="one" type="uint64" default="1" >always 1</field>
		<field name="unk_pc_count" type="uint64" vercond="#PC#">matches the other count on dino entertainer, but ik_count is not present</field>
		<field name="zeros count" type="uint64" >counts the weird padding at the end, usually == bone count; 0 for PZ, JWE2</field>
		<field name="ik_count" type="uint64">max of ik_info's ik_count and ik_targets_count</field>
		<field name="joint count" type="uint64"/>
		<field name="zero 1" type="uint64" default="0"/>
		<field name="zero 2" type="uint64" default="0" until="13"/>
		<field name="zero 3" type="uint64" default="0" vercond="#JWE#"/>

		<field name="names ref" type="Empty"/>
		<!-- index into ms2 string table for bones used here -->
		<field name="name indices" type="ushort" arr1="name count" until="32"/>
		<field name="name indices" type="uint" arr1="name count" since="47"/>
		<field name="inventory name indices" type="ushort" arr1="inv_names_count" until="32"/>
		<field name="name padding" type="PadAlign" template="names ref" arg="16" >align to 16 bytes</field>
		<!-- hook size 8256 -->
		<field name="inverse bind matrices" type="Matrix44" arr1="bind matrix count">used for skinning</field>
		<!-- hook start at 13153 -->
		<field name="bones" type="Bone" arr1="bone count"/>
		<field name="parents" type="ubyte" arr1="parents count" until="52" >255 = root, index in this list is the current bone index, value is the bone's parent index</field>
		<field name="parents" type="ushort" arr1="parents count" since="53" >255 = root, index in this list is the current bone index, value is the bone's parent index</field>
		<field name="parents_padding" type="PadAlign" template="names ref" arg="8" since="32">align to 8 bytes</field>
		<field name="enumeration" type="uint" arr1="enum count" arr2="2" cond="one" since="32" >enumerates all bone indices, 4 may be flags</field>
		<field name="enumeration" type="ubyte" arr1="enum count" cond="one" until="13" >enumerates all bone indices</field>

		<!-- experimental stuff for DLA cpt. hook model -->
		<field name="inventory_datas" type="byte" arr1="inv_data_count" arr2="6" vercond="#DLA#">zeros</field>

		<field name="weirdness" type="short" arr1="8" vercond="#DLA#">-1s and 0s</field>
		<field name="weirdness" type="short" arr1="10" vercond="#ZTUAC#">zeros</field>

		<field name="inventory_datas_2" type="int" arr1="inv_data_count" arr2="2" vercond="#DLA#">zeros</field>

		<field name="MinusPadding" type="MinusPadding" cond="zeros count" arg="zeros count" until="32">weird -1s</field>
		<field name="ZerosPadding" type="ZerosPadding" arg="zeros count" since="47">weird zeros</field>
		<field name="ik info" type="IKInfo" cond="ik_count" arg="#SELF#">IK Data</field>
		<field name="joints" type="JointData" cond="joint count" >joints</field>
	</struct>

	<struct name="MeshCollisionData">
		<field name="optimizer" type="MeshCollisionOptimizer" cond="#ARG#\is_optimized"/>

		<field name="vertices addr" type="Empty"/>
		<field name="vertices" type="float" arr1="#ARG#\vertex count" arr2="3">array of vertices</field>
		<field name="triangles addr" type="Empty"/>
		<field name="triangles" type="ushort" arr1="#ARG#\tri count" arr2="3">triangle indices into vertex list</field>

		<field name="const" type="uint" until="47">?; PC: 32</field> <!-- model version?? coincidence? -->
		<field name="triangle flags" type="uint" arr1="optimizer\tri flags count" cond="const" vercond="!#PC#" until="47">in JWE redwood: always 37</field>
		<field name="triangle_flags_pc" type="short" arr1="#ARG#\tri count" arr2="2" cond="#ARG#\tris_switch" vercond="#PC#">?</field>

		<field name="mesh aligner" type="PadAlign" template="vertices addr" arg="8" until="32"/>
		<field name="zero end" type="uint" since="52" >JWE2 LAG_NaturalWaterPool_Malta_Walls</field>
	</struct>

</fileformat>
