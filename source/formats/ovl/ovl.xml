<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE fileformat>
<fileformat>

	<xi:include href="../ovl_base/ovl_base.xml" xmlns:xi="http://www.w3.org/2001/XInclude" xpointer="xpointer(*/*)" />

	<verattr name="mime_version" access="mime version" index="3" />

    <struct name="MimeEntry" allow_np="true" >
        Description of one mime type or file class.
		Inside the archive not the stored mime hash is used but the extension hash, has to be generated, eg. djb2("bani") == 2090104799
        <field name="name" type="OffsetString" arg="context\names"/>
        <field name="zero_0" type="uint" default="0"/>
        <field name="Mime Hash" type="uint" since="18">hash of this mime, changes with mime version; not used anywhere else in the ovl</field>
        <field name="mime version" type="uint" >usually increments with game</field>
		<field name="file index offset" type="uint">Id of this class type. Later in the file there is a reference to this Id; offset into FileEntry list in number of files</field>
        <field name="file count" type="uint">Number of entries of this class in the file.; from 'file index offset', this many files belong to this file extension</field>
        <field name="zero_1" type="uint" until="17"/>
        <field name="triplet count" type="uint" since="20" >constant per mime, grab this many triplets</field>
        <field name="triplet offset" type="uint" since="20" >index into triplets list</field>
    </struct>

    <struct name="Triplet" allow_np="true">
        3 bytes - constant per mime and version
        <field name="a" type="ubyte">?</field>
        <field name="b" type="ubyte">?</field>
        <field name="c" type="ubyte">?</field>
    </struct>

    <struct name="FileEntry" allow_np="true" >
        Description of one file in the archive
        <field name="basename" type="OffsetString" arg="context\names"/>
        <field name="file hash" type="uint">this hash is used to retrieve the file name from inside the archive</field>
        <field name="pool_type" type="byte" >pool type of this file's root pointer, if part of a set, it's usually the same as set pool type</field>
        <field name="set_pool_type" type="byte" >if this file is part of a set, the set's root entry's pool type, else 0</field>
        <field name="extension" type="ushort" >index into 'Extensions' array</field>
    </struct>

    <struct name="ArchiveEntry" >
        Description of one archive
        <field name="name" type="OffsetString" arg="context\archive_names"/>
        <field name="pools_offset" type="uint">starting index in ovl list of pools, this archive's pools continue for num_pools</field>
        <field name="stream_files_offset" type="uint">starting index into ovl.stream_files</field>
        <field name="num_pools" type="uint" >Total amount of pools in this archive; sum of all PoolGroup.num_pools</field>
        <field name="Num Datas" type="ushort" >Amount of Data Entries</field>
        <field name="num_pool_groups" type="ushort" >Amount of PoolGroup objects at start of this deflated archive.</field>
        <field name="num_buffer_groups" type="uint"/>
        <field name="Num Buffers" type="uint">Amount of buffers in the archive</field>
        <field name="Num Fragments" type="uint" >Amount of Fragments in the archive</field>
        <field name="num_root_entries" type="uint">Number of files in the archive</field>
        <field name="read start" type="uint">Seek to pos to get zlib header for this archive</field>
        <field name="set data size" type="uint" >size of the set and asset entry data</field>
        <field name="compressed_size" type="uint">size of the compressed data for this archive</field>
        <field name="uncompressed_size" type="uint64" >size of the uncompressed data for this archive</field>
        <field name="pools_start" type="uint">byte offset, cumulative size of all pools preceding this archive</field>
        <field name="pools_end" type="uint" >byte offset, pools_start + sum of this archive's pools' sizes</field>
        <field name="ovs_offset" type="uint" >Seemingly unused, can be zeroed without effect ingame in JWE</field>
    </struct>

    <struct name="IncludedOvl" allow_np="true">
        Description of one included ovl file that is force-loaded by this ovl
        <field name="basename" type="OffsetString" arg="context\names">path is relative to this ovl's directory; usually points to ovl files</field>
    </struct>

	<struct name="HeaderPointer" allow_np="true">
		Not standalone, used by RootEntry, Fragment and DependencyEntry
        <field name="pool_index" type="int" default="-1">The index of the MemPool this one relates to; OR, for entries referred to from AssetEntries: -1</field>
        <field name="data offset" type="uint" >the byte offset relative to the start of the MemPool's data</field>
    </struct>

    <struct name="DependencyEntry" allow_np="true">
        Description of dependency; links it to an entry from this archive
        <field name="file hash" type="uint">basename for dependency, for lookup in hash dict. Can be either external or internal.</field>
        <field name="ext_raw" type="OffsetString" arg="context\names">ext for dependency, use : instead of . at the start, eg. :tex</field>
        <field name="file index" type="uint" >index into ovl files, points to the file entry using this dependency</field>
        <field name="link_ptr" type="HeaderPointer" >pointer into flattened list of all archives' pools</field>
    </struct>

    <struct name="AuxEntry" allow_np="true">
        describes an external AUX resource
        <field name="file index" type="uint">index into files list</field>
        <field name="basename" type="OffsetString" arg="context\names"/>
        <field name="size" type="uint">byte count of the complete external resource file</field>
    </struct>

    <struct name="StreamEntry" allow_np="true">
        Description of one streamed file instance. One for every file stored in an ovs.
        Links the main pointers of a streamed file to its user, eg. a texturestream to a tex file.
        --These appear sorted in the order of root entries per ovs.-- only true for lod0, not lod1
        the order does not seem to be consistent
        interestingly, the order of root_entry entries per ovs is consistent with decreasing pool offset
        <field name="stream_offset" type="uint">offset to the stream's root_entry pointer inside the flattened mempools</field>
        <field name="file_offset" type="uint">offset to the user file's root_entry pointer (in STATIC) inside the flattened mempools</field>
        <field name="zero" type="uint"/>
    </struct>

    <struct name="ArchiveMeta" allow_np="true">
        Apparently sizes or offsets for each archive
        <field name="unk_0" type="uint">seemingly unused in JWE</field>
        <field name="unk_1" type="uint">seemingly unused in JWE, subtracting this from ovs uncompressed_size to get length of the uncompressed ovs header</field>
    </struct>

    <struct name="Header" inherit="GenericHeader">
        Found at the beginning of every OVL file
        <field name="num ovs types" type="uint" >counts ovs files with unique paths not matching the ovl name; all LODs of one type count as 1</field>
        <field name="Len Names" type="uint" >length of the Names block below, including 00 bytes, aligned to 8</field>
        <field name="Zero 2" type="uint"/>

        <field name="Num Aux Entries" type="uint" >count of external aux files, ie audio banks</field>
        <field name="num_included_ovls" type="ushort" >count of included ovl files that are available to this ovl</field>
        <field name="Num Mimes" type="ushort" >count of file mime types, aka. extensions with metadata</field>
        <field name="Num Files" type="uint"/>
        <field name="Num Files 2" type="uint" >repeat count of files ??</field>
        <field name="Num Dependencies" type="uint"/>
        <field name="Num Archives" type="uint" >number of archives</field>

        <field name="num_pool_groups" type="uint" >across all archives</field>
        <field name="num_pools" type="uint" >across all archives</field>
        <field name="Num Datas" type="uint" >across all archives</field>
        <field name="Num Buffers" type="uint" >across all archives</field>
        <field name="num_stream_files" type="uint" >number of files in external OVS archives</field>
        <field name="ztuac unk 0" type="uint" >used in ZTUAC elephants</field>
        <field name="ztuac unk 1" type="uint" >used in ZTUAC elephants</field>
        <field name="ztuac unk 2" type="uint" >used in ZTUAC elephants</field>
        <field name="Len Archive Names" type="uint" >length of archive names, aligned to 8</field>
        <field name="Num Files 3" type="uint" >another Num Files</field>
        <field name="Len Type Names" type="uint" >length of the type names portion inside Names block (usually at the start), not counting 00 bytes</field>
        <field name="num_triplets" type="uint" >used in PZ1.6 for the first time</field>
        <field name="Reserved" type="uint" arr1="12">zeros</field>

		<!-- end of fixed header structure -->
        <field name="Names" type="ZStringBufferPadded" arg="Len Names">Name buffer for assets and file mime types.</field>
        <field name="Names_pad_dla" type="ubyte" arr1="(8 - (Len Names #MOD# 8)) #MOD# 8" until="15">used in DLA</field>
        <field name="Mimes" type="MimeEntry" arr1="Num Mimes"/>
        <field name="triplets_ref" type="Empty"/>
        <field name="triplets" type="Triplet" arr1="num_triplets" since="20"/>
        <field name="triplets_pad" type="PadAlign" template="triplets_ref" arg="4" since="20"/>
        <field name="Files" type="FileEntry" arr1="Num Files"/>
        <field name="archive_names" type="ZStringBufferPadded" arg="Len Archive Names">usually STATIC followed by any external OVS names</field>
        <field name="Archives" type="ArchiveEntry" arr1="Num Archives"/>
        <field name="included_ovls" type="IncludedOvl" arr1="num_included_ovls"/>
        <field name="Dependencies" type="DependencyEntry" arr1="Num Dependencies" since="19" vercond="!is_PC2"/>
        <field name="Aux Entries" type="AuxEntry" arr1="Num Aux Entries"/>
        <field name="Dependencies" type="DependencyEntry" arr1="Num Dependencies" until="18">after aux in ZTUAC and PC</field>
        <field name="Dependencies" type="DependencyEntry" arr1="Num Dependencies" since="19" vercond="is_PC2"/>
        <field name="stream_files" type="StreamEntry" arr1="num_stream_files"/>
        <field name="archives_meta" type="ArchiveMeta" arr1="Num Archives"/>
    </struct>

    <struct name="NamedEntry" >
        name is stored in basename and ext attributes
    </struct>

	<!-- From here, structs are for the deflated stream -->

	<struct name="PoolGroup">
		Located at start of deflated archive stream
		<field name="Type" type="ushort" >Type of the pools that follow</field>
		<field name="num_pools" type="ushort" >Amount of pools of that type that follow the pool types block</field>
	</struct>

    <struct name="MemPool" >
        Description of one archive header entry
        <field name="zero1" type="uint64" since="17"/>
		<field name="Size" type="uint">the number of bytes inside this mempool</field>
		<field name="Offset" type="uint">byte offset from the start of the mempools region</field>
        <field name="zero2" type="uint64" until="15"/>
		<field name="File Hash" type="uint">djb2 hash of the first file that points into this mempool</field>
		<field name="Num Files" type="ushort" >unknown count (related to number of files or pointers)</field>
		<field name="Num datas" type="ushort" >amount of data entries referring to this pool?, may just be an artifact of apparently compressed ovs though</field>
		<field name="Ext Hash" type="uint" since="19">JWE: djb2 hash for extension, 0 for PZ</field>
        <field name="zero3" type="uint" since="19"/>
    </struct>
	
	<struct name="DataEntry" >
		32 bytes
		<field name="File Hash" type="uint">djb2 hash</field>
		<field name="Ext Hash" type="uint" since="19">djb2 hash for extension</field>
		<field name="set index" type="ushort" >1-based indexing into set_header.sets; 0 if data is not part of a set</field>
		<field name="buffer count" type="ushort">number of buffers that should be read from list for this entry</field>
        <field name="zero" type="uint" since="19"/>
		<field name="Size 1" type="uint64">size of first buffer, in the case of the ms2 the size 1 is the size of the first two buffers together</field>
		<field name="Size 2" type="uint64">size of last buffer; tex and texstream have all size here</field>
    </struct>

	<struct name="BufferEntry" >
		8 bytes
		<field name="index" type="uint" until="19">index of buffer in file; id from sorting of data entries</field>
		<field name="size" type="uint">in bytes</field>
		<field name="file_hash" type="uint" since="20">id; index is taken from buffer group</field>
    </struct>

	<struct name="BufferGroup" >
		32 bytes
		<field name="buffer_offset" type="uint">first buffer index</field>
		<field name="buffer_count" type="uint">number of buffers to grab</field>
		<field name="ext_index" type="uint">type of extension this entry is for</field>
		<field name="buffer_index" type="uint">which buffer index to populate</field>
		<field name="size" type="uint64">cumulative size of all buffers to grab</field>
		<field name="data_offset" type="uint">first data entry</field>
		<field name="data_count" type="uint">number of data entries to populate buffers into</field>
    </struct>
	
    <struct name="RootEntry" allow_np="true">
        Main file entry in the ovs, one per FileEntry
        <field name="File Hash" type="uint">id (index or djb2) of the file</field>
        <field name="Ext Hash" type="uint" since="19">djb2 of extension</field>
        <field name="struct_ptr" type="HeaderPointer" >points to the main struct of this file OR -1 pointer for assets</field>
    </struct>
	
    <struct name="Fragment" allow_np="true">
		These are to be thought of as instructions for loading. Their order is irrelevant.
        <field name="link_pool" type="int" default="-1">The index of the MemPool this one relates to; OR, for entries referred to from AssetEntries: -1</field>
        <field name="link_offset" type="uint" >the byte offset relative to the start of the MemPool's data</field>
        <field name="struct_pool" type="int" default="-1">The index of the MemPool this one relates to; OR, for entries referred to from AssetEntries: -1</field>
        <field name="struct_offset" type="uint" >the byte offset relative to the start of the MemPool's data</field>
    </struct>
	
	<struct name="SetEntry" allow_np="true">
		the asset indices of two consecutive SetEntries define a set of AssetEntries
        <field name="File Hash" type="uint"/>
        <field name="Ext Hash" type="uint" since="19"/>
		<field name="start" type="uint" >add assets from last set's start up to this index to this set</field>
    </struct>

	<struct name="AssetEntry" allow_np="true">
		refers to root entries so they can be grouped into set entries.
		points to RootEntry with pool_index -1
        <field name="File Hash" type="uint64"/>
        <field name="Ext Hash" type="uint64" since="19"/>
		<field name="root index" type="uint64" >index into root entries array</field>
    </struct>

	<struct name="SetHeader" >
		defines amount of sets and assets
        <field name="set count" type="uint"/>
        <field name="asset count" type="uint"/>
		<field name="sig a" type="uint" default="1065336831">must be 1065336831, apparently 1065336255 in broken DLA ovls</field>
		<field name="sig b" type="uint" default="16909320">must be 16909320</field>
        <field name="sets" type="SetEntry" arr1="set count"/>
        <field name="assets" type="AssetEntry" arr1="asset count"/>
    </struct>

    <struct name="OvsHeader" >
        Description of one archive's content
        <field name="pool_groups" type="PoolGroup" arr1="#ARG#\num_pool_groups"/>
        <field name="pools" type="MemPool" arr1="#ARG#\num_pools"/>
        <field name="data entries" type="DataEntry" arr1="#ARG#\Num Datas"/>
        <field name="buffer entries" type="BufferEntry" arr1="#ARG#\Num Buffers"/>
        <field name="buffer groups" type="BufferGroup" arr1="#ARG#\num_buffer_groups"/>
        <field name="root_entries" type="RootEntry" arr1="#ARG#\num_root_entries"/>
        <field name="fragments" type="Fragment" arr1="#ARG#\Num Fragments"/>
        <field name="set header" type="SetHeader"/>
    </struct>

</fileformat>
