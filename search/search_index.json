{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cobra Tools","text":"<p>Life Modding finds a way.</p> <p>Download </p> <p>A suite of GUI tools for extracting and modifying OVL and OVS archives, as well as editing the associated in-house file formats. Also includes a model plugin for Blender.</p> <p> </p>"},{"location":"Credits/","title":"Credits","text":"<ul> <li>Planet Zoo, Cobra, Frontier and the Frontier Developments logo are trademarks or registered trademarks of Frontier Developments, plc.</li> <li>Jurassic World, Jurassic World Fallen Kingdom, Jurassic World Evolution, Jurassic World Evolution 2 and their respective logos are trademarks of Universal Studios and Amblin Entertainment, Inc.</li> <li>Daemon1, DennisNedry1993 and Inaki for initial modding attempts and documentation.</li> <li>mpeterv for luacheck</li> <li>REDxEYE for FastMesh</li> <li>bnnm for wwiser</li> <li><code>texconv</code> from DirectXTex is used internally to convert to and from DDS textures.</li> </ul>"},{"location":"Disclaimers/","title":"Disclaimers &amp; Legal","text":""},{"location":"Disclaimers/#disclaimers","title":"Disclaimers","text":"<ul> <li>It is recommended to back up all mod files and vanilla game files. Game patches may interfere with or break mods, requiring the mod to be redone or updated. </li> <li>Not all file formats are fully supported at this time. Some formats may be not be extractable or injectable. Some formats that extract or inject may not function properly in game.</li> </ul>"},{"location":"Disclaimers/#legal-notice-and-terms-of-conduct","title":"Legal Notice and Terms Of Conduct","text":"<p>This software is developed under 'fair use' by enthusiasts and is not affiliated with Universal\u00a9 or Frontier\u00ae in any form.</p> <p>Download &amp; Terms of Conduct</p> <p>Download Cobra Tools  Please agree to the Terms of Conduct below</p> <p>Download Cobra Tools </p> <p>By downloading and using this software, you agree to the following conditions:</p> <ul> <li> Use this software at your own risk. It may cause damage to you, your equipment or your data. The authors are not responsible for your actions.</li> <li> Do NOT use this software to circumvent copy protections. Especially, do not try to unlock downloadable content for free, share official artwork or intellectual property or engage in so-called data mining to announce game content before an official announcement.</li> <li> Do NOT affect online modes of the game drastically using this software. Do not try to gain any advantage over other players. Online gameplay and modifications should be restricted as much as possible and not encouraged.</li> <li> Secure permission to use other parties' work in your mods. This includes but is not limited to using IP, artwork, concepts, designs, and 3D models (e.g. porting models from another game, including other Frontier games). If you don't have the approval of the copyright holder(s), be prepared to face the consequences.</li> <li> Adhere strictly to the license of incorporated third-party works This includes correct attribution, linking, and disclaiming as per the license requirements wherever work made with this software is displayed or uploaded.</li> <li> Do NOT seek monetary compensation for mods made with this software. Mods created with the tools must be freely available. This means no charging money, asking for donations, or offering exclusivity (even if temporary) for access to mods. Mod updates should also be free.</li> <li> Do NOT monetize ported work. Without explicit permission, one should not monetize someone else's work. This means that using the tool to republish others' works should not be done for profit, but for the modding community. Mods with ported assets must opt out of any direct revenue. Unsolicited donations for the work done are still fine, as long as they are not tied to any specific ported mod.</li> </ul> <p>If you still have doubts, consider checking Frontier's official Mod Policy.</p> <ul> <li> I agree to the Terms of Conduct</li> </ul>"},{"location":"Download/","title":"Download","text":""},{"location":"Download/#installation","title":"Installation","text":"<p>Warning</p> <ol> <li>Read the instructions steps carefully before downloading anything or you will miss important steps.</li> <li>If updating the tools, please also refer to Updating.</li> </ol>"},{"location":"Download/#installing-prerequisites","title":"Installing Prerequisites","text":"<p>You need to have installed:  </p> <ul> <li> <p>Python 3.11 64-bit </p> <p>IMPORTANT</p> <ul> <li>Make sure you select the option \"Add Python to PATH\" during installation</li> <li>32-bit versions of Python are not recommended.</li> </ul> </li> </ul> <ul> <li>Microsoft Visual C++ Redistributable 2017 x64 (1)</li> <li>Microsoft Visual C++ Redistributable 2013 x86 (2)</li> </ul> <ol> <li>Required for texture conversion</li> <li>Required for Lua decompilation</li> </ol>"},{"location":"Download/#download_1","title":"Download","text":"Download &amp; Terms of Conduct <p>Download Cobra Tools  Please agree to the Terms of Conduct below</p> <p>Download Cobra Tools </p> <p>By downloading and using this software, you agree to the following conditions:</p> <ul> <li> Use this software at your own risk. It may cause damage to you, your equipment or your data. The authors are not responsible for your actions.</li> <li> Do NOT use this software to circumvent copy protections. Especially, do not try to unlock downloadable content for free, share official artwork or intellectual property or engage in so-called data mining to announce game content before an official announcement.</li> <li> Do NOT affect online modes of the game drastically using this software. Do not try to gain any advantage over other players. Online gameplay and modifications should be restricted as much as possible and not encouraged.</li> <li> Secure permission to use other parties' work in your mods. This includes but is not limited to using IP, artwork, concepts, designs, and 3D models (e.g. porting models from another game, including other Frontier games). If you don't have the approval of the copyright holder(s), be prepared to face the consequences.</li> <li> Adhere strictly to the license of incorporated third-party works This includes correct attribution, linking, and disclaiming as per the license requirements wherever work made with this software is displayed or uploaded.</li> <li> Do NOT seek monetary compensation for mods made with this software. Mods created with the tools must be freely available. This means no charging money, asking for donations, or offering exclusivity (even if temporary) for access to mods. Mod updates should also be free.</li> <li> Do NOT monetize ported work. Without explicit permission, one should not monetize someone else's work. This means that using the tool to republish others' works should not be done for profit, but for the modding community. Mods with ported assets must opt out of any direct revenue. Unsolicited donations for the work done are still fine, as long as they are not tied to any specific ported mod.</li> </ul> <p>If you still have doubts, consider checking Frontier's official Mod Policy.</p> <ul> <li> I agree to the Terms of Conduct</li> </ul>"},{"location":"Download/#installing-python-dependencies","title":"Installing Python Dependencies","text":"<p>Opening any of the GUI tools after installing Python 3.11 and the redistributables should auto-install the Python dependencies for you. You may also be prompted to update outdated packages via this same prompt. If you have issues please see Installing Dependencies Manually.</p> <p></p> <p>Simply follow the instructions, typing <code>y</code> and hitting <code>Enter</code>.</p>"},{"location":"Download/#installing-dependencies-manually","title":"Installing Dependencies Manually","text":"<p>If you would like to install the dependencies manually:</p> <ol> <li>Open the Cobra Tools folder in Windows File Explorer.</li> <li>In the File Explorer address bar, type <code>cmd</code> and hit <code>Enter</code>. This will open a command prompt in your Cobra Tools folder.</li> <li> <p>In the command prompt type the following line and hit <code>Enter</code></p> <pre><code>python.exe -m pip install --upgrade pip &amp;&amp; pip install .[gui]\n</code></pre> <p>IMPORTANT</p> <p>There is a dot <code>.</code> at the end of the command <code>.[gui]</code>. If you do not open <code>cmd</code> in your Cobra Tools folder, you will need to replace <code>.</code> with the full path to the folder.</p> </li> </ol>"},{"location":"Download/#troubleshooting-errors","title":"Troubleshooting Errors","text":"<p>If you still encounter errors after following these instructions, please visit our Tools FAQ.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home<ul> <li>Download</li> <li>Updating</li> <li>Disclaimers</li> <li>Credits</li> </ul> </li> <li>Blog</li> <li>Development</li> <li>Guides</li> <li>Modding FAQ</li> <li>Tools FAQ</li> </ul>"},{"location":"Updating/","title":"Updating","text":"<p>Mid-Project Tool Updates</p> <p>Updating the tools in the middle of a project may require re-extraction of files due to format changes, or the recreation of .blend files by re-importing your models.  Thus, it is recommended to avoid upgrades unless you are willing to update your project files.</p>"},{"location":"Updating/#gui-tools","title":"GUI Tools","text":"<p>To update the tools themselves, you should delete the contents of your cobra-tools folder entirely and extract the newer files into the same folder. This clears out any old, unused, or cached files that may interfere with tool updates.</p>"},{"location":"Updating/#python-dependencies","title":"Python Dependencies","text":"<p>The tools have an auto-updater to handle Python dependency updates for you, which will operate the same as the automatic installer in Installing Python Dependencies.</p>"},{"location":"Updating/#blender-plugin","title":"Blender Plugin","text":"<p>Construction</p> <p>This area is currently under construction!</p>"},{"location":"Updating/#symlinking-guide","title":"Symlinking Guide","text":"<p>If you would prefer to ensure that your GUI tools and Blender Plugin are always synced, you can create a symlink so that both operate from the same location.</p> <p>Notes</p> <ol> <li>For the sake of this guide we will assume your Cobra Tools location is <code>C:\\cobra-tools-master</code> and that the Blender addons folder (if already installed) is called <code>cobra-tools-master</code>. Adjust these accordingly in the steps below</li> <li>If you delete or move your cobra-tools folder, the symlink in Blender addons will become invalid and you will have to repeat this process.</li> <li>When updating Blender versions (e.g. 4.0 to 4.1), you will have to repeat this process with the new Blender version in the path.</li> </ol> <ol> <li> <p>If the plugin is already installed, delete your existing <code>cobra-tools-master</code> folder located at:</p> <p><code>C:\\Users\\USERNAME(1)\\AppData\\Roaming\\Blender Foundation\\Blender\\4.0(2)\\scripts\\addons</code></p> <ol> <li>Your Windows username</li> <li>Your version of Blender, e.g. 4.0</li> </ol> </li> <li> <p>Open up a command prompt as administrator.  Press Win and type <code>cmd</code>, then select Run as Administator. If prompted to elevate privileges, click Yes.</p> <p></p> </li> <li> <p>Type the following command in the command prompt and hit Enter, after adjusting <code>USERNAME</code>, Blender version, and the path to your cobra-tools folder:</p> <p><code>mklink /J \"C:\\Users\\USERNAME(1)\\AppData\\Roaming\\Blender Foundation\\Blender\\4.0(2)\\scripts\\addons\\cobra-tools-master\" \"C:\\cobra-tools-master(3)\"</code></p> <ol> <li>Your Windows username</li> <li>Your version of Blender, e.g. 4.0</li> <li>Replace this with the path of your Cobra Tools folder</li> </ol> </li> <li> <p>If successful, you will see a directory symlink located at:</p> <p><code>C:\\Users\\USERNAME(1)\\AppData\\Roaming\\Blender Foundation\\Blender\\4.0(2)\\scripts\\addons</code></p> <ol> <li>Your Windows username</li> <li>Your version of Blender, e.g. 4.0</li> </ol> </li> <li> <p>When updating your tools, do not delete your cobra-tools folder or the symlink will become invalid. Remove the inner contents of the cobra-tools folder and extract the new files into it.</p> </li> <li> <p>Now, your GUI tools and Blender Plugin will always be in sync. You will also be able to access <code>blender_plugin.log</code> from your main cobra-tools folder without having to navigate all the way through to the Blender addons folder.</p> </li> </ol>"},{"location":"Development/","title":"Development","text":""},{"location":"Development/#code-contributions","title":"Code Contributions","text":"<p>If you are interested in contributing to the codebase:</p> <ol> <li> <p>Install the dev dependencies. From <code>cobra-tools</code> directory run:     <pre><code>python.exe -m pip install --upgrade pip &amp;&amp; pip install .[gui,dev]\n</code></pre></p> </li> <li> <p>Then install the pre-commit hooks:</p> <pre><code>pre-commit install -f\n</code></pre> </li> </ol>"},{"location":"Development/#documentation-contributions","title":"Documentation Contributions","text":"<p>If you are interested in contributing to the documentation:</p> <ol> <li> <p>Install the mkdocs dependencies. From <code>cobra-tools</code> directory run:     <pre><code>python.exe -m pip install --upgrade pip &amp;&amp; pip install .[doc]\n</code></pre></p> </li> <li> <p>Then, you may run mkdocs locally with:</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>Your documentation edits and additions will be refreshed live as long as the mkdocs server is running.</p> </li> </ol>"},{"location":"Development/Documentation/Documentation-Guidelines/","title":"Documentation Guidelines","text":""},{"location":"Development/Documentation/Documentation-Guidelines/#document-metadata","title":"Document Metadata","text":""},{"location":"Development/Documentation/Documentation-Guidelines/#title","title":"Title","text":"<p>It is recommended to supply a title at the top of the document with the following syntax:</p> Some-Document.md<pre><code>---\ntitle: Some Better Document Title\n---\n</code></pre> <p>This allows for nice, short URIs in the URL while providing a more descriptive title for the document.</p>"},{"location":"Development/Documentation/Documentation-Guidelines/#description","title":"Description","text":"<p>It is recommended to supply a title at the top of the document with the following syntax:</p> Some-Document.md<pre><code>---\ndescription: A summary of what this document entails\n---\n</code></pre> <p>The description is useful as it will display in social cards i.e. the preview when linked in Discord, etc.</p>"},{"location":"Development/Documentation/Documentation-Guidelines/#icon","title":"Icon","text":"<p>Icon Naming</p> PrefixPath <ul> <li><code>:material-</code></li> <li><code>:octoicons-</code></li> <li><code>:simple-</code></li> <li><code>:fontawesome-brands-</code></li> <li><code>:fontawesome-regular-</code></li> <li><code>:fontawesome-solid-</code></li> </ul> <ul> <li><code>material/</code></li> <li><code>octoicons/</code></li> <li><code>simple/</code></li> <li><code>fontawesome/brands/</code></li> <li><code>fontawesome/regular/</code></li> <li><code>fontawesome/solid/</code></li> </ul> <p>You may want to supply a custom icon for the page which will be displayed in navigation entries. The syntax is as follows:</p> Some-Document.md<pre><code>---\nicon: material/file-document-edit-outline\n---\n</code></pre> <ol> <li>You can search available icons at the following mkdocs-material page.</li> <li>After finding a suitable icon, you must convert it from the <code>:icon-name:</code> format to an extensionless path.<ul> <li> Refer to the Icon Naming guide to the right, or the path can be found in the <code>.icons</code> folder in the mkdocs-material repository.</li> <li> Do not leave the <code>:</code> on either side of the icon path</li> </ul> </li> </ol> <p>The result of using all three is as follows:</p> Some-Document.md<pre><code>---\ntitle: Some Better Document Title\ndescription: A summary of what this document entails\nicon: material/file-document-edit-outline\n---\n</code></pre>"},{"location":"Development/Documentation/Documentation-Guidelines/#file-and-folder-naming","title":"File and Folder Naming","text":"<ul> <li> For correct URIs both Markdown files and folders must use <code>Title-Case</code>, with whitespace replaced by dashes.<ul> <li>Exception: <code>index.md</code> for index pages.</li> <li>Exception: <code>SUMMARY.md</code> for navigation.</li> </ul> </li> <li> DO NOT use whitespace in subfolder or Markdown file names.</li> </ul> GoodBad <pre><code>/docs/\n  |-- Guides\n    |-- Some-Guide\n      |-- index.md\n      |-- Page-One.md\n      |-- Page-Two.md\n</code></pre> <pre><code>/docs/\n  |-- Guides\n    |-- Some guide\n      |-- index.md\n      |-- page one.md\n      |-- Page-two.md\n</code></pre>"},{"location":"Development/Documentation/Documentation-Guidelines/#headings","title":"Headings","text":"<ul> <li> For consistency with the combined TOC/nav, please use short Title Case headings.</li> <li> DO NOT use sentence case or long, run-on heading text.</li> </ul> GoodBad <pre><code>## Using Manager Interfaces\n</code></pre> <pre><code>## Calling other Managers code using their interface\n</code></pre>"},{"location":"Development/Documentation/Documentation-Guidelines/#discord-channel-links","title":"Discord Channel Links","text":"<p>OpenNaja server channels may often need to be linked to, here is a list for copying/pasting where necessary (note the Copy button in each code block):</p> <ul> <li> rules <pre><code>**[:discord-rules: rules](https://discord.com/channels/680909673607463131/680910494151868532)**\n</code></pre></li> <li> guidelines <pre><code>**[:discord-channel: guidelines](https://discord.com/channels/680909673607463131/1223893560881840151)**\n</code></pre></li> <li> announcements <pre><code>**[:discord-announcements: announcements](https://discord.com/channels/680909673607463131/680910508756303894)**\n</code></pre></li> <li> modding-help-pz <pre><code>**[:discord-topic: modding-help-pz](https://discord.com/channels/680909673607463131/1020301021756543017)**\n</code></pre></li> <li> modding-help-jwe2 <pre><code>**[:discord-topic: modding-help-jwe2](https://discord.com/channels/680909673607463131/1020306232281677916)**\n</code></pre></li> </ul>"},{"location":"Development/Documentation/Documentation-Primer/","title":"Documentation Primer","text":"<ul> <li>For all features reference, see mkdocs-material Reference</li> <li> <p>For built-in plugin reference, see mkdocs-material Plugins</p> <p>Plugins</p> <p>Unused plugins will need to be enabled, consult the plugin documentation for enabling them in <code>mkdocs.yml</code></p> </li> </ul>"},{"location":"Development/Documentation/Documentation-Primer/#navigation","title":"Navigation","text":"<p>The documentation uses mkdocs-literate-nav for navigation.</p>"},{"location":"Development/Documentation/Documentation-Primer/#external-linking","title":"External Linking","text":"<p>Please use the Markdown attribute lists extension to add <code>target=_blank</code> to external links.  This opens them in a new tab and will not interrupt documentation flow.</p> UsageResult <pre><code>[Link](https://www.google.com/){:target=_blank}\n</code></pre> <p>Link</p>"},{"location":"Development/Documentation/Documentation-Primer/#relative-linking","title":"Relative Linking","text":""},{"location":"Development/Documentation/Documentation-Primer/#documents","title":"Documents","text":"<p>Links to other Markdown files must use paths relative to the source Markdown file, and include the <code>.md</code> extension.</p> UsageResult <pre><code>[Link](../Reverse-Engineering/OVL-File-Formats.md)\n</code></pre> <p>Link</p>"},{"location":"Development/Documentation/Documentation-Primer/#images-and-other-assets","title":"Images and Other Assets","text":"<p>Other assets such as images must also be linked relative to the source Markdown file. </p>"},{"location":"Development/Documentation/Documentation-Primer/#docsassetsimages","title":"docs/assets/images","text":"<p>For images in the root assets folder, you will need to traverse every subfolder with <code>../</code></p> UsageResult <pre><code>![Image](../../assets/Cobra_Tools_Logo.png)\n</code></pre> <p></p>"},{"location":"Development/Documentation/Documentation-Primer/#images-subfolders","title":"Images Subfolders","text":"<p>Remote vs Local</p> <p>All asset links should start with at least <code>./</code> because of the way Markdown files in subfolders are rendered to a URI. For some reason links without <code>./</code> can resolve correctly locally but not remotely.</p> <pre><code>/docs/\n  |-- Guides\n    |-- Plugin\n      |-- images/\n        |-- image.png     # /docs/Guides/Plugins/images/image.png\n      |-- index.md        # /docs/Guides/Plugins/index.md\n      |-- Page.md         # /docs/Guides/Plugins/Page.md\n</code></pre> <p>In both <code>index.md</code> and <code>page.md</code>, links to <code>Plugin/images</code> should start with <code>./images/</code>.  Links starting with <code>images/</code> will not work for <code>page.md</code> as the URI will be <code>Guides/Plugin/Page/</code>.</p>"},{"location":"Development/Documentation/Documentation-Primer/#annotations","title":"Annotations","text":"<p>For full documentation see Annotations Usage</p>"},{"location":"Development/Documentation/Documentation-Primer/#admonitions","title":"Admonitions","text":"<p>For full documentation see Admonitions Usage.</p>"},{"location":"Development/Documentation/Documentation-Primer/#admonition-classes","title":"Admonition Classes","text":"<p>All non-quoted text after <code>!!!</code> becomes a CSS class. Some useful built-in classes are <code>inline</code> and <code>end</code>.</p>  inline end inline <p>Lorem ipsum</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla.</p> <pre><code>!!! info inline end \"Lorem ipsum\"\n\n    Lorem ipsum dolor sit amet, consectetur\n    adipiscing elit. Nulla et euismod nulla.\n</code></pre> <p>Use <code>inline end</code> to align to the right (left for rtl languages).</p> <p>Lorem ipsum</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla.</p> <pre><code>!!! info inline \"Lorem ipsum\"\n\n    Lorem ipsum dolor sit amet, consectetur\n    adipiscing elit. Nulla et euismod nulla.\n</code></pre> <p>To customize specific admonitions:  </p> <ol> <li>Create a CSS class in extra.css</li> <li> <p>Use this class in the admonition declaration.</p> <p>Example: Wider Inline Admonitions</p>  extra.cssUsage Result without inline-wide Result with inline-wide <pre><code>/* The admonition type is not included in the selector, for use in all inline admonitions */\n.md-typeset .admonition.inline.inline-wide {\n    width: 20rem;\n}\n</code></pre> <pre><code>!!! info inline inline-wide end \"Info Title\"\n    Info text\n</code></pre> <p>Info Title</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Info Title</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> </li> </ol>"},{"location":"Development/Documentation/Documentation-Primer/#custom-admonitions","title":"Custom Admonitions","text":"<p>Some new admonitions have been created for the cobra-tools documentation.  For reference on how to create them, see Custom Admonitions.</p>"},{"location":"Development/Documentation/Documentation-Primer/#faq","title":"FAQ","text":"<p>The FAQ admonition is used for Q&amp;A formatting, with the Question as the custom admonition name.</p> UsageResult <pre><code>!!! faq \"Question?\"\n    Answer\n</code></pre> <pre><code>!!! faq \"Q. Question 1?&lt;br&gt;Q. Question 2?\"\n    Answer for both questions\n</code></pre> <p>Tip</p> <p>Be mindful of the use of quotes, line breaks, and indentation in the above example.</p> <p>Question?</p> <p>Answer</p> <p>Q. Question 1?Q. Question 2?</p> <p>Answer for both questions</p>"},{"location":"Development/Documentation/Documentation-Primer/#construction","title":"Construction","text":"<p>The Construction admonition is used to caution users of documents still under development.</p> UsageResult <pre><code>!!! construction\n    This page is still under construction!\n</code></pre> <p>Tip</p> <p>Be mindful of the use of quotes, line breaks, and indentation in the above example.</p> <p>Construction</p> <p>This page is still under construction!</p>"},{"location":"Development/Documentation/Documentation-Primer/#content-tabs","title":"Content Tabs","text":"<p>For full documentation see PyMdown Extensions Tabbed</p> <p>Paragraphs, code blocks, and entire sections can be turned into tabs with the following syntax:</p> UsageResult <pre><code>=== \"Tab 1\"\n\n    Tab 1 Content\n\n=== \"Tab 2\"\n\n    Tab 2 Content\n</code></pre> Tab 1Tab 2 <p>Tab 1 Content</p> <p>Tab 2 Content</p> <p>Tip</p> <p>Be mindful of the use of quotes, line breaks, and indentation in the above example.</p>"},{"location":"Development/Documentation/Documentation-Primer/#snippets","title":"Snippets","text":"<p>For full documentation see PyMdown Extensions Snippets</p> UsageResult <pre><code>--8&lt;-- \"blender-log.md\"\n</code></pre> <p><code>C:\\Users\\USERNAME(1)\\AppData\\Roaming\\Blender Foundation\\Blender\\4.0(2)\\scripts\\addons\\cobra-tools-master\\blender_plugin.log</code></p> <ol> <li>Your Windows username</li> <li>Your version of Blender, e.g. 4.0</li> </ol> <p>Tip</p> <p>It helps to remember the syntax as ASCII scissors <code>8&lt;</code> surrounded by two dashes</p>"},{"location":"Development/Reverse-Engineering/OVL-File-Formats/","title":"Reverse Engineering an OVL File Format","text":"<p>This tutorial assumes that you have basic knowledge of a hex editor, data types and reverse engineering in general.</p>"},{"location":"Development/Reverse-Engineering/OVL-File-Formats/#workflow","title":"Workflow","text":"<ol> <li> <p>Download the source code for cobra tools, open in an IDE. For a new format, you need to do three things:</p> <ul> <li>In <code>/source/formats/</code>, duplicate an existing OVL file format's folder (eg. <code>animalresearch</code>) and rename it to your new format. Rename the XML inside of it, too.</li> <li>Run <code>python -m codegen</code> to generate <code>.py</code> files from the XML structure definitions in <code>/source/formats/</code>. These will be put in in <code>/generated/formats/</code>. Whenever you have made a change to an XML definition, run the codegen again to update the <code>.py</code> files.</li> <li>In <code>/modules/formats/</code>, create a new <code>.py</code> file with a class that handles your format. This tells the tools which XML-defined struct class to use (eg. <code>ResearchRoot</code>) and which file extension to apply this to (eg. <code>.animalresearchunlockssettings</code>). Minimal example: <pre><code>from generated.formats.animalresearch.compound.ResearchRoot import ResearchRoot\nfrom modules.formats.BaseFormat import MemStructLoader\n\n\nclass AnimalresearchunlockssettingsLoader(MemStructLoader):\n    target_class = ResearchRoot\n    extension = \".animalresearchunlockssettings\"\n</code></pre></li> </ul> </li> <li> <p>Open an OVL file with your format in the OVL editor, run <code>Util &gt; Dump Debug Data</code>.</p> <p>DEV MODE</p> <p>Certain dev functions require the existence of a <code>.git</code> folder in the <code>cobra-tools</code> location. Either checkout the repository with <code>git</code>, or create this folder to enable Dev Mode.</p> </li> <li> <p>Open the <code>.stack</code> file that was created in your OVL's folder. Search for your file extension. You will find, for example, the following:</p> <pre><code>FILE [  0 |    896] (  64) cc_anubis.fgm\nPTR @ 16   -&gt; SUB [  0 |    164] ( 120)\nPTR @ 24   -&gt; SUB [  0 |    288] ( 608)\nPTR @ 32   -&gt; SUB [  0 |   1008] (  40)\n    DEP @ 0    -&gt; cc_anubis.paosamplertexture.tex\n    DEP @ 8    -&gt; cc_anubis.pbasecolourtexture.tex\n    DEP @ 16   -&gt; cc_anubis.pflexicolourmaskssamplertexture.tex\n    DEP @ 24   -&gt; cc_anubis.pmetalsmoothnesscavitysamplertexture.tex\n    DEP @ 32   -&gt; cc_anubis.pnormaltexture.tex\nPTR @ 40   -&gt; SUB [  0 |      0] ( 164)\n</code></pre> </li> <li> <p>The above tells you that the main struct for <code>cc_anubis.fgm</code> starts in pool number 0 at offset <code>896</code> and occupies <code>64</code> bytes, starting at that offset.</p> </li> <li> <p>Open the pool <code>.dmp</code> file in a hex editor. If you set the width to <code>8</code> (not always useful), navigate to offset <code>896</code>, you will see the following:</p> <pre><code>Offset(d) 00       04\n00000896  05000000 00000000  ........\n00000904  26000000 00000000  &amp;.......\n00000912  40504F49 4E544552  @POINTER\n00000920  40504F49 4E544552  @POINTER\n00000928  40504F49 4E544552  @POINTER\n00000936  40504F49 4E544552  @POINTER\n00000944  00000000 00000000  ........\n00000952  00000000 00000000  ........\n</code></pre> <p>The hex and the stack log tell you a number of things:</p> <ul> <li>There are 4 pointers in your struct, which occupy 32 bytes in total (from 912-944, or relative to the struct: 16-48). For convenience, pointers are always given with <code>PTR @ relative_offset</code> in the log and marked <code>@POINTER</code> in the <code>.dmp</code>.</li> <li>There are likely integers at relative offsets 0 (<code>5</code>) and 8 (<code>38</code>). These could represent counts for one of the pointers.</li> <li>This file depends on 5 external files (in this case <code>.tex</code> textures, which makes sense, as a <code>.fgm</code> material has to refer to them). These are marked <code>DEP @ relative_offset</code> in the log and marked <code>@DEPENDS</code> in the <code>.dmp</code>. But these do not appear directly in the main struct.</li> </ul> <p>Let's start by writing an XML representation for the main struct, which covers its 64 bytes: <pre><code>    &lt;struct name=\"FgmHeader\" inherit=\"MemStruct\"&gt;\n        &lt;field name=\"count_0\" type=\"uint64\" /&gt;\n        &lt;field name=\"count_1\" type=\"uint64\" /&gt;\n        &lt;field name=\"ptr_0\" type=\"Pointer\" /&gt;\n        &lt;field name=\"ptr_1\" type=\"Pointer\" /&gt;\n        &lt;field name=\"ptr_2\" type=\"Pointer\" /&gt;\n        &lt;field name=\"ptr_3\" type=\"Pointer\" /&gt;\n        &lt;field name=\"unk_0\" type=\"uint64\" /&gt;\n        &lt;field name=\"unk_1\" type=\"uint64\" /&gt;\n    &lt;/struct&gt;\n</code></pre> Setting <code>type</code> to <code>Pointer</code> will make the tool read those 8 bytes as a pointer and then read a sub-struct at the address that this pointer points to. But first, you need to figure out the data layout of the pointer's sub-struct for this to work.</p> </li> <li> <p>Look at the sub-structs pointed to by the pointers.</p> <p>For <code>PTR @ 16</code>, you'll find 120 bytes starting at offset 164. You'll notice a repetition in the pattern after 24 bytes. <pre><code>Offset(d) 00       04\n00000160           AC020000      \u00ac...\n00000168  08000000 00000000  ........\n00000176  00000000 00000000  ........\n00000184  00000000 BE020000  ....\u00be...\n00000192  08000000 01000000  ........\n00000200  00000000 00000000  ........\n00000208  00000000 D1020000  ....\u00d1...\n........\n</code></pre> The size <code>24 (size of sub-sub-struct) * 5 (count) = 120 (size of sub-struct)</code> indicates that the count is actually used for this pointer, and you're looking at an array. The whole struct for <code>PTR @ 16</code>, now set to 24 bytes width. Now you can see the sub-sub-struct is likely composed of 6 <code>uint</code>s. The first of these could be a string offset, the second is constantly 8, the third increments (an index?) and the rest are zeros.</p> <pre><code>Offset(d) 00       04       08       12       16       20\n\n00000144                                               AC020000                      \u00ac...\n00000168  08000000 00000000 00000000 00000000 00000000 BE020000  ....................\u00be...\n00000192  08000000 01000000 00000000 00000000 00000000 D1020000  ....................\u00d1...\n00000216  08000000 02000000 00000000 00000000 00000000 F1020000  ....................\u00f1...\n00000240  08000000 03000000 00000000 00000000 00000000 16030000  ........................\n00000264  08000000 04000000 00000000 00000000 00000000           ....................\n</code></pre> <p>For <code>PTR @ 32</code>, you'll find 40 bytes, occupied only by 5 dependency links. The stack log tells you which external file dependency points there. <pre><code>Offset(d) 00       04\n00001008  40444550 454E4453  @DEPENDS\n00001016  40444550 454E4453  @DEPENDS\n00001024  40444550 454E4453  @DEPENDS\n00001032  40444550 454E4453  @DEPENDS\n00001040  40444550 454E4453  @DEPENDS\n</code></pre></p> </li> <li> <p>Now you have some more knowledge of the format, so time to document the struct in XML syntax for the codegen. This will result in something like the following:</p> <p><pre><code>    &lt;struct name=\"FgmHeader\" inherit=\"MemStruct\"&gt;\n        &lt;field name=\"count_0\" type=\"uint64\" /&gt;\n        &lt;field name=\"count_1\" type=\"uint64\" /&gt;\n        &lt;field name=\"array_0\" type=\"ArrayPointer\" template=\"Sub1\" arg=\"count_0\"/&gt;\n        &lt;field name=\"ptr_1\" type=\"Pointer\" /&gt;\n        &lt;field name=\"dependencies\" type=\"Pointer\" /&gt;\n        &lt;field name=\"ptr_3\" type=\"Pointer\" /&gt;\n        &lt;field name=\"unk_0\" type=\"uint64\" /&gt;\n        &lt;field name=\"unk_1\" type=\"uint64\" /&gt;\n    &lt;/struct&gt;\n\n    &lt;struct name=\"Sub1\" inherit=\"MemStruct\"&gt;\n        &lt;field name=\"offset\" type=\"uint\" /&gt;\n        &lt;field name=\"constant_eight\" type=\"uint\" /&gt;\n        &lt;field name=\"index\" type=\"uint\" /&gt;\n        &lt;field name=\"zero_0\" type=\"uint\" /&gt;\n        &lt;field name=\"zero_1\" type=\"uint\" /&gt;\n        &lt;field name=\"zero_2\" type=\"uint\" /&gt;\n    &lt;/struct&gt;\n</code></pre> Notice that <code>ptr_0</code> has been renamed to <code>array_0</code>, its <code>type</code> changed to <code>ArrayPointer</code>. Its sub-struct is set to <code>template=\"Sub1\"</code>, counted by <code>arg=\"count_0\"</code>.</p> </li> </ol>"},{"location":"Development/Reverse-Engineering/OVL-File-Formats/#tips-tricks","title":"Tips &amp; Tricks","text":"<p>Identifying counts for pointers</p> <p>You'll want to compare the data size of the sub-structs with candidates for counts. If you find integer divisions, you have a likely match. Be aware that these are memory representations and (array) data can be and often is padded to align with 16 bytes offsets.</p> <p>In most but not all formats, the count somewhat counter-intuitively follows the array pointer.</p> <p>Data type of sub-structs</p> <p>A quick way to determine the data type of sub-structs is looking at the stack log.</p> <ul> <li>Are there any pointers in the sub-struct? \u2192 it must be a struct too</li> <li>Is its length not divisible by 8? \u2192 it is most likely a ZString</li> </ul> <p>Finding rare pointers</p> <p>You can easily miss out on conditional pointers if you don't look at all files of a format in the stack log, as null pointers don't necessarily appear in the stack log.</p> <p>Once you have defined and implemented a preliminary struct, open an OVL containing your format with <code>Debug Mode</code> turned on. All instances of the struct are then checked for pointers missing from the XML specification and you will receive warnings in the console if any are found.</p> <p>Naming arrays and counts</p> <p>If you follow naming conventions for arrays and counts, the count is automatically hidden from the XML on extraction and calculated on injection. Consider the following examples:</p> <ul> <li> dependencies, dependency_count</li> <li> dependencies, dependencies_count</li> <li> dependencies, num_dependencies</li> </ul> <p>Homogeneous data with no obvious pattern</p> <p>Assuming you have identified the data type already: Modify data, put ingame, observe changes to identify the meaning of the data.</p> <p>Comparing to original</p> <p>Once you have a suitable XML description, extract your file and inject it back into the ovl. If it injected successfully, select the file in the GUI and click Utils &gt; Compare, then select the OVL that contains the original file. If there are differences, you will find warnings in the log. If the injected file is identical to the original, the log will tell you so. You then have a working description of your format, at least for that particular file.</p>"},{"location":"Guides/","title":"Guides","text":"<p>Construction</p> <p>This page is currently under construction!</p>"},{"location":"Guides/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Guides</li> <li>ACSE</li> <li>Blender Plugin</li> <li>Textures</li> <li>*/</li> <li>*.md</li> <li>Supported Formats</li> </ul>"},{"location":"Guides/Supported-Formats/","title":"Supported Formats","text":""},{"location":"Guides/Supported-Formats/#main-formats","title":"Main Formats","text":"Format Purpose Editor ASSETPKG OVL resolve name Any text editor MDL2 &amp; MS2 Mesh data link &amp; buffer Blender 3.6+ &amp; Cobra Plugin FGM Fragment Material properties FGM Editor TEX / PNG / DDS Textures, GUI images Any image editor for PNG (Recommended: GIMP, Photoshop), Any text editor for TEX (change compression settings) FDB Stats, asset definitions SQLite database editor (Recommended: SQliteStudio) TXT In-game texts Any text editor MOTIONGRAPH Behavior graph for animation system Any text editor (Note: Not every .motiongraph fully supported) BANI &amp; BANIS Baked animations, only location and rotation keys Blender 3.6+ &amp; Cobra Plugin (partial import) MANI &amp; MANIS Animations supporting location, rotation, scale, shear, shape keys and IK Blender 3.6+ &amp; Cobra Plugin (full support for uncompressed, partial support for compressed) MATERIALCOLLECTION Additional material options &amp; linking Matcol Editor LUA Game logic Currently not reliably decompiled PSCOLLECTION Game database queries Any text editor XML Game logic FCT Font File BNK/AUX Sound Files WWise to convert .wav to .wem USERINTERFACEICONDATA OVL resolve name/path Any text editor GFX Provides UI context Flash decompiler (Recommended: JPEXS)"},{"location":"Guides/Supported-Formats/#miscellaneous-formats","title":"Miscellaneous Formats","text":"<p>These are editable in any XML or plaintext editor.</p> Format Purpose .accountcustomisation .accountlevelsdata .animalresearchunlockssettings Animal Research .assetpacklist .assetpackobjectlists .brush .buildingbiomelayer .buildingset .campaigndata .cinematic Cutscenes .curve .datastreams .decalsettings .dinosaurmaterialeffects Dinosaur Materials .dinosaurmateriallayers Dinosaur Materials .dinosaurmaterialpatterns Dinosaur Materials .dinosaurmaterialvariants Dinosaur Materials .dlcentitlements .enumnamer List of values for specdefs .fmvdesc .frendercontextset Rendering .frenderfeatureset Rendering .frenderlodspec Rendering .guesteconomy .guestonrideanimsettings .habitatboundarydata Barriers .habitatboundaryprop Barriers .helpnodedata .island .janitorsettings .logicalcontrols Custom Keybinding customization .lut .mechanicresearchsettings Mechanic Research .mergedetails .missiondata .motiongraphvars .particleatlas .particleeffect .pathextrusion Paths - Curb / Post / Endcap model definitions .pathmaterial Paths - Path Part &lt;-&gt; Material associations .pathjoinpartresource Paths - Scenery &lt;-&gt; Path snapping/joining .pathresource Paths - Main Path definition .pathsupport Paths - Path &lt;-&gt; SupportSet associations .pathtype Paths - Type &lt;-&gt; Min/Max Width associations .supportset Rides and Paths .physicssurfacesxmlres .renderfeaturecollection Rendering .renderparametercurves Rendering .renderparameters Rendering .restaurantsettings .ridesettings Rides .scaleformlanguagedata UI .sceneryobjectresource .semanticflexicolours FlexiColour Semantic Channel definitions .spatialuitheme .specdef Game component validation .spl Splines .terraindetaillayers Terrain .terrainindexeddetaillayers Terrain .texatlas .trackedridecar Rides .trackelement Rides .trackmesh Rides .trackstation Rides .uimoviedefinition UI .voxelskirt Terrain .weatherevents .wmeta .world .wsm .xmlconfig Settings UI configuration presets"},{"location":"Guides/ACSE/","title":"ACSE","text":"<p>Construction</p> <p>This page is currently under construction!</p>"},{"location":"Guides/ACSE/Dev-Lua/","title":"dev/Lua","text":"<p>Note</p> <p>The functionality explained here requires ACSE installed in the game to work.</p>"},{"location":"Guides/ACSE/Dev-Lua/#introduction","title":"Introduction","text":"<p>ACSE provides a few methods for quickly scripting and prototyping code for the game that does not require packing a complete content pack or mod. One of this methods it the local development init.lua file. This file only exists in your local copy of the game (JWE1, JWE2 or PZ) and can be used to speed up your modding capabilities.</p> <p>Warning</p> <p>Do not add anything to this file that is required for other Content Packs or mods to work because this file is not distributed widely, as part of ACSE or any other mod.</p>"},{"location":"Guides/ACSE/Dev-Lua/#file-location-and-default-template-code","title":"File location and default template code.","text":"<p>ACSE makes use of a special folder accesible for the game code located in <code>{platform]\\Dev\\Lua</code> where platform is the game folder. If this folder exist, ACSE will look for a special file called init.lua and execute it during the game database bootstrap (the initial ACSE injection point). You can have any Lua code included in this file, however due to the current boostrap step it is being injected in the game it is very likely that many of the game API or features/facilities were not available for your code to use.</p> <p>The best use of this file is to structure it as if it is another mod or content pack script. The most basic template of the Init.lua file is provided below:</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    dev/Lua/init.lua (Template file, valid for all Cobra Engine games)\n--/  @author  inaki\n--/  @version 1.0\n--/\n--/  @brief  Creates a development environment in the running game.\n--/\n--/  The purpose of this file is to allow rapid testing/debugging of\n--/  different things without needing to create a custom mod for it.\n--/\n--/  This file is added by ACSE as a Database manager, exposing all\n--/  it CallOnContent methods to the game.\n-----------------------------------------------------------------------\nlocal global = _G\nlocal api = global.api\nlocal pairs = pairs\nlocal type = type\nlocal ipairs = ipairs\nlocal next = global.next\nlocal string = global.string\n\n-- Include additiona lua modules as required.\n-- local table = require(\"Common.tableplus\")\n-- local Main = require(\"Database.Main\")\n-- local GameDatabase = require(\"Database.GameDatabase\")\n\n-- @brief main module definition\nlocal Dev = module(...)\n\n-- @brief Database after Init setup. This function is called after Dev:Init() and can\n-- be used to alter the setup of your mod if needed.\nDev.Setup = function()\n    global.api.debug.Trace(\"Dev:Setup()\")\nend\n\n-- @brief Database soft restart. This function is called when the game is doing a restart\n-- of the Lua module, meaning after :Shutdown() it will call :Init(). Use this function\n-- to cache any data you dont want/need to reinitialize.\nDev.ShutdownForReInit = function()\n    global.api.debug.Trace(\"Dev:ShutdownForReInit()\")\nend\n\n-- @brief Database Shutdown. This function is called when the database system is being shutdown,\n-- usually when the game is closing. You can add your own custom shutdown commands here.\nDev.Shutdown = function()\n    global.api.debug.Trace(\"Dev:Shutdown()\")\n\n    -- Remove custom commands. Note: tShellCommand is\n    -- created during Init.\n    for i, oCommand in ipairs(Dev.tShellCommands) do\n        global.api.debug.UnregisterShellCommand(oCommand)\n    end\n\n    Dev.tShellCommands = nil\n    global.api.debug.Trace(\"Dev:Shutdown() Finished\")\n\n    -- Add your custom shutdown code after this line.\nend\n\n-- @brief Database init\nDev.Init = function()\n    global.api.debug.Trace(\"Dev:Init()\")\n\n    -- Register our own custom shell commands in this section. Custom shell commands can be\n    -- executed through Lua scripting or using the ACSEDebug console window. To run a shell\n    -- command from Lua you can call the debug API:\n    -- local _, sResult = global.api.debug.RunShellCommand(\"Echo \" .. sStringToEcho)\n    --\n    Dev.tShellCommands = {\n        --\n        -- Custom command to echo a string back. The input string will be displayed in the\n        -- UI console or added to the game log. Note, this command include a example of how\n        -- to add and process arguments to a command.\n        global.api.debug.RegisterShellCommand(\n            -- Function to run\n            function(tEnv, tArgs)\n                if #tArgs &lt; 1 then\n                    return false, \"Needs at least one argument.\"\n                end\n                return true, global.tostring(tArgs[1])\n            end,\n            \"Echo {string}\",\n            \"Writes the input string back to the console.\\n\"\n        ),\n        --\n        -- Crash to desktop. Simple command that will cause Lua to fail forcing a game crash.\n        global.api.debug.RegisterShellCommand(\n            function(tEnv, tArgs)\n                local t = require(tArgs[3]:value())\n            end,\n            \"&amp;Crash&amp;To&amp;Desktop\",\n            \"Crash the game.\\n\"\n        ),\n\n        -- Add more commands after this line.\n\n    }\n\n    -- Add any custom additional Init() code after this line.\nend\n\n--\n-- Game database section\n--\n-- Here you can add your custom game database functions. The game database is a facility \n-- provided by the game engine to store and use different data. Since the database is \n-- accessible globaly through the game, any content pack can have access to any information \n-- created or updated by other content packs. This data however is not persistent: it needs to\n-- be initialised everytime the game is run, and will get lost when the game is closed.\n--\n\n-- Definition of our own database methods\nDev.tDatabaseMethods = {\n    --\n    -- Example of custom database method, can be called using:\n    -- local nResult = GameDatabase.DevTest()\n    DevTest = function()\n        return 42\n    end\n    -- ...\n}\n\n-- @brief adds our custom database methods to the main game database\nDev.AddDatabaseFunctions = function(_tDatabaseFunctions)\n    for sName, fnFunction in pairs(Dev.tDatabaseMethods) do\n        _tDatabaseFunctions[sName] = fnFunction\n    end\nend\n\n--\n-- Player table additions. Player table additions allows adding custom code and data\n-- to the player table, being used during the entire game. The player table controls\n-- everything related to the current game owner, including achievements or other\n-- global stats and information through the entire game, not specific to a certain\n-- park/zoo/island (this information will be stored in the save file instead).\n--\n\n-- Definition of our own player methods\nDev.tPlayerMethods = {\n    --\n    -- Example new player method, can be called using:\n    -- tPlayer:DevPlayerTest(true)\n    DevPlayerTest = function(_tPlayer, bTest)\n        _tPlayer.bTestingBooleanValue = bTest\n    end\n    -- ...\n}\n\n-- @brief adds our custom methods to the player table\nDev.AddPlayerMethods = function(_tPlayerMethods)\n    for sMethod, fnMethod in pairs(Dev.tPlayerMethods) do\n        _tPlayerMethods[sMethod] = fnMethod\n    end\nend\n\n--\n-- Game player hooks. The game provides a few hooks when a player data is being\n-- processed. This hooks can be used to access data persistently between game runs.\n-- Being able to save and load data whenever it is needed can be used to load and\n-- save custom setting changes through different game executions, meaning the data\n-- will not get lost when you close the game.\n--\n\n-- @brief Allows adding attributes to a new player, called when a new player save\n-- file is being created. Add your own attributes here.\nDev.AddPlayer = function(_tPlayer)\n    global.api.debug.Trace(\"Dev:AddPlayer()\")\n    --_tPlayer.bBooleanValue = false\nend\n\n-- @brief Allows saving information to file in this player profile. Called when the\n-- player data is being saved to disk, allows to store your own data for this player\n-- persistently.\nDev.SavePlayer = function(_tPlayer, _saver)\n    global.api.debug.Trace(\"Dev:SavePlayer()\")\n    -- _saver is the table being saved with our data.\n    --_saver.bBooleanValue = _tPlayer.bBooleanValue\nend\n\n-- @brief Allows loading information from file of this player profile. Called when a\n-- a player save is being loaded, allows you to read data saved previsouly.\nDev.LoadPlayer = function(_tPlayer, _loader)\n    global.api.debug.Trace(\"Dev:LoadPlayer()\")\n    -- _loader is the table loaded from the file with our data\n    --_tPlayer.bBooleanValue = _loader.bBooleanValue\nend\n\n-- @brief Notifies a player is removed. Called when a player save is being deleted (\n-- usually on a player reset) allows you to read data before it will get destroyed.\nDev.RemovePlayer = function(_tPlayer)\n    global.api.debug.Trace(\"Dev:RemovePlayer()\")\n    --_tPlayer.bBooleanValue = _loader.bBooleanValue\nend\n\n--\n-- Custom ACSE managers section.\n--\n-- Managers are like Monobehaviors for Unity, they are specific class type scripts that\n-- will run depending on the game stage. If you need a specific piece of code executed\n-- each frame, or when the selected map/park/zoo is loading, you'd probably need to add\n-- a custom manager.\n--\n-- Managers need to be injected in the right environment. ACSE provides functions to\n-- inject managers in the main menu screen (globe menu in PZ or main menu in JWE) and the\n-- main park game (Zoo in PZ or island in JWE). You can add the same manager to both\n-- environments if you want, juts need to be aware what environment are your running your\n-- script in. Depending on the environment, other managers might be available and your\n-- code can interact with them (e.g. the Weather manager will not be available in the\n-- main menu screen).\n\n-- List of custom managers to force injection on the starting screen. It requires the\n-- manager lua files to be available in the following location:\n-- Dev\\Lua\\Managers\\MyCustomStartManager.lua\nDev.tStartScreenManagers = {\n    --['Managers.MyCustomStartManager'] = {},\n}\n\n-- @brief Add our custom Manager to the starting screen. If required, the lua modules\n-- will be imported from the file system.\nDev.AddStartScreenManagers = function(_fnAdd)\n    local tData = Dev.tStartScreenManagers\n    for sManagerName, tParams in pairs(tData) do\n        global.api.debug.RunShellCommand(\"ImportModule \" .. sManagerName)\n        _fnAdd(sManagerName, tParams)\n    end\nend\n\n-- List of custom managers to force injection on a park. It requires the\n-- manager lua files to be available in the following location:\n-- Dev\\Lua\\Managers\\MyCustomParkManager.lua\nDev.tParkManagers = {\n    --['Managers.MyCustomParkManager'] = {},\n}\n\n-- @brief Add our custom Manager to the park/zoo/island game. If required, the lua\n-- modules will be imported from the file system.\nDev.AddParkManagers = function(_fnAdd)\n    local tData = Dev.tParkManagers\n    for sManagerName, tParams in pairs(tData) do\n        global.api.debug.RunShellCommand(\"ImportModule \" .. sManagerName)\n        _fnAdd(sManagerName, tParams)\n    end\nend\n\n--\n-- List of custom managers to force injection on different game environments\n-- separated by environment. To be used when the game has additional game\n-- environments (or game modes) other than the start screen and park managers.\n-- (e.g. in JWE2 the Species Viewer is a custom environment/game mode.)\n-- Note, you will need to know the exact name of the environment script. The lua\n-- manager module file has to be available at:\n-- Dev\\Lua\\Managers\\CustomEnvironmentManager.lua\nDev.tManagers = {\n    -- [\"Environments.WhateverEnvironment\"] = {\n    --    [\"Managers.CustomEnvironmentManager\"] = {},\n    --},    \n}\n\n-- @brief Add our custom Manager to the starting screen\nDev.AddManagers = function(_fnAdd)\n    local tData = Dev.tManagers\n    for sEnvironmentName, tParams in pairs(tData) do\n        _fnAdd(sEnvironmentName, tParams)\n    end\nend\n\n--\n-- Custom ACSE Prefabs section.\n--\n-- This section of the init.lua file allows you to define custom prefabs that will be\n-- injected to the game. Note: at this moment it is not possible to load models or\n-- other files from the file system so all your game assets need to be added to the\n-- game by a custom content pack. You can use this prefabs injection to modify in-game\n-- existing prefabs or create custom ones without models too.\n--\n-- This prefabs are considered ACSE prefabs and can be listed with the custom prefab\n-- commands added by the mod.\n\n-- List of custom prefabs\nDev.tPrefabs = {}\n\n-- @brief add custom prefabs to the game\nDev.AddLuaPrefabs = function(_fnAdd)\n    local tData = Dev.tPrefabs\n    for k, tInfo in global.ipairs(tData) do\n        for sPrefabName, tParams in pairs(tInfo) do\n            _fnAdd(sPrefabName, tParams)\n        end\n    end\nend\n\n--\n-- ACSE Custom components section\n--\n-- This section allows you to inject custom componetns to the game for testing.\n-- Note that components are definitions required by some prefabs and if you are\n-- distributing a content pack with these prefabs you need to make sure to include\n-- any required component in the Content Pack. Usually the components included\n-- in this init.lua file are only used for testing on custom prefabs that don't\n-- need to be distributed, like debug assets etc.\n\n-- List of custom components to inject into the game. It requires the\n-- manager lua files to be available in the following location:\n-- Dev\\Lua\\Components\\MyCustomComponent.lua\nDev.tComponents = {}\n\n-- @brief add custom components to the game\nDev.AddLuaComponents = function(_fnAdd)\n    local tData = Dev.tComponents\n    for sComponentName, tParams in pairs(tData) do\n        global.api.debug.RunShellCommand(\"ImportModule \" .. sComponentName)\n        _fnAdd(sComponentName, tParams)\n    end\nend\n-- EOF\n</code></pre>"},{"location":"Guides/ACSE/Dev-Lua/#init-file-usage","title":"Init file usage","text":"<p>The init.lua file was conceived to allow modders to create a custom development environment, with any additional tweakables, commands, managers and files as needed for their daily modding work. This file is not intended to be distributed although it is encouraged to share as much information and resusable code as possible.</p> <p>Ideally, if a modder is working on a specific project, the init file will include helper function and commands or other relevant information required for the development of this or other modules. Examples of custom commands can include: a method to list if a prop item has all the information defined (to validate the prop mod being worked on), a method to list all spawned props, a method to change or spawn props automatically, etc.</p> <p>You are free to share your init.lua file with other modders too if you want, althought it is understandable that some of the contents of the init file can be very specific to a modder development workflow that can hardly be of interest for other modders. </p> <p>Just apply common sense when creating your own development environment. If you come out with a list of interesting managers and commands that can help a specific modding workflow (e.g. adding new animals or props), you might want to consider creating a 'modding' content pack (or mod) with those specific files and commands to assist others developing their mods. The purpose of this init.lua is to assist you creating a rapid development local setup only.</p>"},{"location":"Guides/ACSE/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Scripting Guide<ul> <li>Content Packs</li> <li>Game Databases</li> <li>Game Managers</li> <li>LuaDatabase and Prefabs</li> </ul> </li> <li>*/</li> <li>*.md</li> </ul>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/","title":"Tweakables and Shell Commands","text":"<p>Note</p> <p>The functionality explained here requires ACSE installed in the game to work.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#introduction","title":"Introduction","text":"<p>When developing a Mod, it is important to have several facilities that can assist you to trigger certain events, execute certain code or being able to tweak a few parameters without having to build the Mod and launch the game again, or reaching certain gampleay situation for the events to happen the natural way. For this Cobra Engine uses two different features in development that we have reintroduced through ACSE: Tweakables and Shell Commands.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#tweakable-variables","title":"Tweakable variables","text":"<p>Tweakable variables (from now on Tweakables) is a method to define a variable for your Mod that can be altered with ACSE debug functions. ACSE will register all the Tweakables created by any Manager, Component or database, and exposed them through the ACSE Debug UI. They can later be list and modified from the Debug console with the 'ListTweakables' and 'SetTweakable' commands.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#creating-a-tweakable-variable","title":"Creating a Tweakable variable.","text":"<p>Tweakables can have different types, and currently ACSE supports: Integer, Float and Boolean. These are some examples of how to define Tweakable variables:</p> <p><pre><code>local f_MyFloatValue1 = api.debug.CreateDebugTweakable( api.debug.Tweakable_Float, \"Testing.variables.floatvalue1\", 60, 0.5, 1000, 1)\nlocal b_MyBoolValue1  = api.debug.CreateDebugTweakable( api.debug.Tweakable_Bool, \"Testing.variables.Boolean1\", true)\nlocal i_MyIntValue1   = api.debug.CreateDebugTweakable( api.debug.Tweakable_Int32, \"Testing.OtherCategory.Intval1\", 1, 1, 100, 1)\n</code></pre> The arguments to create a Tweakable are: - Type: any of Tweakable_Float, Tweakable_Bool, Tweakable_Int32, Tweakable_UInt32, Tweakable_Int64, Tweakable_UInt64, Tweakable_fVector1 - Name: whatever string name you want to use, it is better to use a clear name based on the variable functionality. - Default value: (must be in the type of the Tweakable) a float, boolean, etc. - Minimum value: minimum value of this variable - Maximum value: maximum value of this variable - Step value: Step value (to move between minimum and maximum value).</p> <p>CreateDebugTweakable will create a global variable object and will return that object from the call. When attempting to create an already existing Tweakable, the function will return the existing one.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#accessing-a-tweakable-variable","title":"Accessing a Tweakable variable","text":"<p>To read or write the value from a Tweakable all you need to do is call any of the functions: - GetValue() will return the current value casted to the Tweakable type. - SetValue(value) will store a new value. Needs to be casted to the right type.</p> <p>So, following with our previous examples, valid ways to access the Tweakables we just created are:</p> <p><pre><code>  api.debug.Trace(\" The value of f_MyFloatValue1 is \" .. tostring( f_MyFloatValue1:GetValue() ))\n\n  local int = 10 + i_MyIntValue1:GetValue()\n\n  if b_MyBoolValue1:GetValue() == true then b_MyBoolValue1:SetValue(false)\n</code></pre> You are just free to use them in your code as normal variables. The only difference is that they are global and can be modified from outside your code, for example through the ACSEDebug console. Example of the commands to modify these Tweakables are:</p> <pre><code> SetTweakable Testing.OtherCategory.Intval1 15\n SetTweakable Testing.variables.floatvalue1 6.5\n Testing.variables.Boolean1 false\n</code></pre>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#shell-commands","title":"Shell Commands","text":"<p>Shell Commands are predefined functions that allow to execute certain actions on demand. There are some default commands introduced by ACSE, but since these actions are game-dependant usually they are provided from external mods. Examples of these commands (and how specific they are) for Jurassice World Evolution 2 include spawning a custom dinosaur, starting/stopping a storm, or loading an island save file. Other commands could be generic enough to work on all games, including a command to retrieve the localized version of a string, or to list all the loaded prefabs by the engine.</p> <p>SetTweakable is another shell command that is provided by ACSE itself, allowing the modification of any Tweakable variable. Some commands will have/need arguments to operate, and some of these arguments may be optional. Arguments are defined by type, for example {uint32} or {float}, and to make them optional they will be surounded by brackets [{string}].</p> <p>This is a list of existing commands as a sample:</p> <ul> <li>PrintDigSites</li> <li>DisplaySubtitle {string} {float}</li> <li>OrbitEntityIDCamera {uint32}</li> <li>ListCommands [{string}]</li> <li>ListTweakables [{string}]</li> </ul> <p>To get more information about a command you can type <code>Help commandName</code> in the debug console, and it will return a detailed description of the command and its arguments. For example, ListTweakables will display the entire list of known Tweakables, and if you specify a string it will use that string to filter the output to include only Tweakables that have that string in their name. Other commands require all their arguments to work, for example DisplaySubtitle requires both a subtitle name and the time in seconds to keep the text displayed.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#creating-a-shell-command","title":"Creating a Shell Command","text":"<p>To create a shell command you will need to call the api.debug.RegisterShellCommand function:</p> <p><pre><code>   local command1 = api.debug.RegisterShellCommand(\n      function(tEnv, tArgs)\n        -- do something\n        return \n      end,\n      \"ResetCurrentIsland\", \n      \"Reset the state of the current island to its starting state\\n\"\n    )\n</code></pre> The arguments for RegisterShellCommand are: - Function to be executed when the command is issued. - Command definition string: will include the command Name and/or any arguments required defined by type. - Command description text.</p> <p>This is a more complex definition of a command including optional and required arguments: <pre><code>   local command2 = api.debug.RegisterShellCommand(\n      function(tEnv, tArgs)\n        -- do something\n        return \n      end,\n      \"Storm start|stop {string} [{float}]\", \n      \"Starts the storm specified by name in the first argument or stops the current active storm\\n\"\n    )\n</code></pre> It is important to save the shell command object returned by RegisterShellCommand and destroy when the code wont be available anymore (e.g. if you have a manager or a database controller, you will create your Shell Commands on Init() and destroy then on Shutdown(), or any attempt to execute the commands will fail and possible crash the game.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#removing-a-shell-command","title":"Removing a shell command","text":"<p>When your code wont be available anymore, you can destroy the existing commands by calling api.debug.UnregisterShellCommand( CommandObject ). The argument for this function is the object created by RegisterShellCommand. Following up with the examples, you will destroy these commands by calling:</p> <p><pre><code>api.debug.UnregisterShellCommand( command1 ) \napi.debug.UnregisterShellCommand( command2 ) \n</code></pre> Note: it is important to unregister all the Shell Commands you have created.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#executing-a-shell-command","title":"Executing a shell command","text":"<p>You can execute Shell Commands from either the debug console or through code, calling api.debug.RunShellCommand( commandString). Some examples could be (assuming the commands do exist):</p> <p><pre><code>  api.debug.RunShellCommand(\"SetTweakable Testing.OtherCategory.Intval1 15\")\n  api.debug.RunShellCommand(\"Game.Quit\")\n</code></pre> In the debug console all you have to do is type the command and press enter.</p>"},{"location":"Guides/ACSE/Tweakables-ShellCommands/#anatomy-of-a-shell-command","title":"Anatomy of a shell command.","text":"<p>Lets go back for a second to the definition of a shell command</p> <pre><code>   local command2 = api.debug.RegisterShellCommand(\n      function(tEnv, tArgs)\n        -- do something\n        return \n      end,\n      \"Storm start|stop {string} [{float}]\", \n      \"Starts the storm specified by name in the first argument or stops the current active \" ..\n      \"storm immediately or after the seconds specified by the second argument\\n\"\n    )\n</code></pre> <p>This command is defined to accept two or there arguments, if there is a second argument it will be a string name of the storm type, if there is a third argument it will be a float value. The command function will receive the arguments in the tArgs table, and will also receive a copy of the current world Environment table in case it needs to access any of the current active managers through their interfaces.</p> <p>Imagine a different command, one that actually uses the game API and is easier to implement.</p> <p><pre><code>   local command3 = api.debug.RegisterShellCommand(\n      function(tEnv, tArgs)\n        if #tArgs &lt; 1 then\n            api.debug.Trace(\"ParkControl requires an action between: open or close\")\n            return\n        end\n        if type(tArgs[1]) ~= \"string\" or tArgs[1]~= 'open' or tArgs[1] ~= 'close' then\n            api.debug.Trace(\"Wrong door control command, use open or close\")\n            return\n        end\n\n        -- perform action:\n        local worldAPI = api.world.GetWorldAPIs()\n        local parkAPI  = worldAPI.park\n\n        if tArgs[1] == 'open' then\n           ParkAPI:SetParkOpenForGuests(true)\n        end\n        if tArgs[1] == 'close' then\n           ParkAPI:SetParkOpenForGuests(false)\n        end\n        return \n      end,\n      \"ParkControl open|closed\", \n      \"opens or closes the park for guests\\n\"\n    )\n</code></pre> In your custom commands you want to have at least the minimum fail safe for argument checking so you don't crash the game for using a command incorrectly. </p> <p>You can add as many commands as you want, but ideally you want to have commands that helps you speeding up your modding requirements. For example, a command to control storms is useful if you plan to develop a mod that adds or modifies the existing storm system, or if you are working on a mod that modifies the storm damage. This way you don't need to wait for a storm to come randomly to check your modding results.</p> <p>Finally remember that you need to Unregister the commands when your module is no longer available to avoid misuses or even the game crashing.</p> <p>Both Tweakables and Shell Commands can be very useful for modding purposes, allowing you to change values and create states without forcing you to test-play everything.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/","title":"Content Pack Setup","text":"<p>These instructions are applicable to the following titles:</p> <ul> <li>Jurassic World Evolution</li> <li>Jurassic World Evolution 2</li> <li>Planet Coaster</li> <li>Planet Zoo</li> </ul>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#content-packs","title":"Content Packs","text":"<p>Cobra Engine supports additional content modules called Content Packs. Whenever Cobra Engine finds a Content Pack, it will perform a set of actions to initialize and include it once the game runs. The game will find new Content Packs looking for a <code>Manifest.xml</code> file within the subfolders of the game, usually starting from <code>{platform}(1)\\ovldata</code></p> <ol> <li>platform can be win64, win32, etc. </li> </ol> <p>Loading Content Packs</p> <p>The Cobra Engine will find all the modules initially through a folder search, but will load them sorted alphabetically. Consider this if you need your Content Pack to load before or after another Content Pack.</p> <p>When the game finds the Manifest file, it will first validate that this Content Pack has not been loaded yet. If the Content Pack is new, it will try loading the Initialization resources, and then the Main data. There could be different types of content included in a single pack (maps, animals, building elements, etc.), but they all will have the same structure:</p> <ul> <li>Manifest file</li> <li>Init OVL</li> <li>Main OVL</li> <li>Other OVL files</li> </ul> <p>Note</p> <p>A Content Pack does not need both Init and Main OVL files, but at least one of them needs to be present.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#creating-the-basic-modcontent-pack-structure","title":"Creating the Basic Mod/Content Pack Structure","text":"<p>The following instructions will show you how to create your first Content Pack.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#content-pack-location-and-folder","title":"Content Pack Location and Folder","text":"<p>Navigate into the game ovldata folder and create a custom folder named after your mod. If we were to use 'ExampleContentPack' as our mod name, we would create the <code>ovldata\\ExampleContentPack</code> folder.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#adding-a-manifest-file","title":"Adding a Manifest File","text":"<p>The Manifest file defines the Content Pack; it gives the module a name used later by the engine to bootstrap the content initialization and a unique ID used to check if the module has been loaded before. It is important that these two (Name and ID) are unique for the module to load properly.</p> <p>Content of <code>ovldata\\ExampleContentPack\\Manifest.xml</code> <pre><code>&lt;ContentPack version=\"1\"&gt;\n  &lt;Name&gt;ExampleContentPack&lt;/Name&gt; &lt;!-- This must match your folder name --&gt;\n  &lt;ID&gt;9a1fce40-4dce-11ec-81d3-0242ac130003&lt;/ID&gt; &lt;!-- You must replace this UUID --&gt;\n  &lt;Version&gt;1&lt;/Version&gt;\n  &lt;Type&gt;Game&lt;/Type&gt;\n&lt;/ContentPack&gt;\n</code></pre></p> <p>UUID</p> <p>You need your own UUID, you can visit this UUID Generator to create one. Replace the value inside <code>&lt;ID&gt;&lt;/ID&gt;</code></p> <p>Name</p> <p>It is vital to name the Content Pack after the folder it is contained in for various reasons such as ACSE naming requirements.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#creating-the-content-packages","title":"Creating the Content Package(s)","text":"<p>Inside your Content Pack folder, add a subfolder called Main. If you also need some initialization (will explain later) Create an Init folder too. The content of your module folder Will look like this:</p> <pre><code>ovldata\\ExampleContentPack\\Init\novldata\\ExampleContentPack\\Main\novldata\\ExampleContentPack\\Manifest.xml\n</code></pre>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#other-required-or-optional-folders","title":"Other required or optional folders.","text":"<p>While you have total freedom on how to name any extra OVL files included by your package, the game engine will also look for specific files/folders inside your module, like Localisation files. If your module has strings that need translation, you will need to provide the data through a localisation folder tree for the different languages.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#content-pack-resources","title":"Content Pack Resources","text":"<p>Anything inside the module OVL files will be considered a resource for the game, regardless of its mime type; however, some resources will be treated differently by the game engine precisely depending on their mime type. It is important to understand that OVL files are loaded on-demand, and therefore your resources in 'Init' will not be able to access your resources in the 'Main' OVL files, or any other OVL file your Content Package has that has not been loaded yet.</p> <p>To begin with, we will add a harmless file without any purpose to the Main.ovl file. Create the <code>ExampleContentPack.txt</code> inside the <code>ExampleContentPack\\Main</code> folder and type the following in it:</p> <pre><code>Version: 1.0\n</code></pre>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#packing-your-content","title":"Packing Your Content","text":"<p>Now it is time to create the OVL files for your Content Pack. Run the <code>cobra-tools\\ovl_tool_gui.py</code> script and perform the following actions:</p> <ul> <li>Select the right title from the game dropdown list.</li> <li>Click File &gt; New (Ctrl+N) and select the <code>ExampleContentPack\\Main</code> folder. The tool will try loading all the known files and show the list of OVL contents.</li> <li>Click File &gt; Save (Ctrl+S). This saves the OVL to <code>ExampleContentPack\\Main.ovl</code>.</li> </ul> <p>At this point, the tool has created the <code>ExampleContentPack\\Main.ovl</code> file from the contents of the <code>ExampleContentPack\\Main</code> folder. Your module folder should look like this now:</p> <pre><code>ovldata\\ExampleContentPack\\Init\novldata\\ExampleContentPack\\Main\novldata\\ExampleContentPack\\Main.ovl\novldata\\ExampleContentPack\\Manifest.xml\n</code></pre> <p>Because the tool only allows the creation of an OVL file at a time, you will need to repeat this process for every folder with content in your module, and you don't need to pack folders that don't have any files on them. The tool will try to guess the name of the file based on the last folder it loaded the content from, but don't forget to double check that you are using the right folder and name for your output OVL file.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#distributing-the-content-pack","title":"Distributing the Content Pack","text":"<p>If you want to share your Content Pack, you only need to distribute the Content Pack folder containing your Manifest.xml and OVL files. Inside ovldata, create a ZIP file from your Content Pack folder and save it. Open your ZIP file and remove any directory and file not required from it. Any folder such as <code>Init</code> or <code>Main</code> used for <code>File &gt; New</code> in OVL tool does not need to be included in the package. </p> <p>In this example, the ZIP content will look like this:</p> <p><pre><code>ExampleContentPack\\\n    Main.ovl\n    Manifest.xml\n</code></pre> You can share this ZIP file now. To use it, all a person has to do is unzip the Content Pack folder inside the ZIP to the ovldata folder.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Content-Packs/#final-notes","title":"Final Notes","text":"<p>Not all file types can be imported at this time. There is a list of supported mime types you can check.</p> <p>The game does not load loose files from the file system; all the resources need to be imported into an OVL file. Therefore, you will need to repeat the packing process every time you modify a file in your content; however, you will only need to repack the specific folder where the modified file is.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/","title":"Game Databases","text":"<p>Lua scripting for Cobra Engine is not complicated; the problem is the context in which you run your Lua script. Some of these contexts (e.g. park managers) require the injection of your Lua script through ACSE; however, there are other contexts where the game can be scripted without the need for ACSE. One of these contexts which are initialized early and available throughout the game is the Game Database.</p> <p>The Cobra Engine uses a modular approach for its internal runtime database. Most of the game configuration is done and made available through the Game Database. Whether it is the cost of a lion in Planet Zoo or the list of available dinosaurs in Jurassic World Evolution, the Game Database holds this information. There is a set of database modules pre-defined in the game's main script (gamescript), but the database driver can load additional modules during the initialization process of every Content Pack.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#using-the-game-database","title":"Using the Game Database","text":"<p>There are different ways to interact with the database and perform CRUD operations on it while the game is running, but this will happen outside of the context of the main database and will be covered later.</p> <p>For now, to access the Game Database through the exposed game API, all you need to do is require the corresponding module and call its functions; however, the content of the database depends on the game title. For example, we can get an <code>Island</code> definition from the database in Jurassic World Evolution 2 with this code:</p> <p><pre><code>local GameDatabase = require(\"Database.GameDatabase\")\nlocal tIslandData = GameDatabase.GetIslandTable('Challenge_01_Taiga')\n</code></pre> The Game Database will return the <code>Island</code> information that we can now modify at our own will. There are more <code>Island</code> related functions in Jurassic World Evolution 2 available, like <code>AddIsland</code>, <code>RemoveIsland</code>, <code>RemoveAllIslands</code>, <code>SaveIsland</code>, and <code>LoadIsland</code>. These functions have been added to the Game Database by the <code>Island</code> Database Manager, which has been loaded as part of a Content Pack.</p> <p>At this point, we still do not have a Lua context to run our code in.</p> <p>To address this, we continue expanding our ExampleContentPack project from Part 1, adding database support. This step is optional and only required if we want to have our custom data loaded into the game database. In addition to having our custom Lua code added to the database, our Lua code will be executed inside the game database context. This will be our first Lua execution point for our Content Pack.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#game-database-hot-plug-module-implementation","title":"Game Database Hot-Plug Module Implementation","text":"<p>The Game Database allows for hot-plugin definition in two different initialization steps, one being the content merging process and the other being the database operation.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#game-database-content-merging","title":"Game Database Content Merging","text":"<p>We will create a custom database module in our Content Pack to interact with the game during the database initialization process. The game will try to merge all the database information from all Content Packs. For that, the game will look for any file inside the Init or Main OVL files called 'Databases.{contentpackname}.lua\" and load it.</p> <p>Start with creating the following file <code>ExampleContentPack\\Init\\Databases.ExampleContentPack.lua</code> with the following content: <pre><code>-- ExampleContentPack Database script\n-- This script will hook into the GameDatabase content merging process\n\n-- This little block is required for non-compiled Lua scripts. It re-defines some globals for use within the script\nlocal global = _G\nlocal api = global.api\nlocal debug = api.debug\nlocal table = global.table\nlocal require = require\nlocal string = string\nlocal ExampleContentPackDatabase = module(...)\n\nlocal tConfig = {\n    -- Tell the main Game Database controller to load the following FDB files\n    tLoad = {},\n    -- Tell the game to create and/or merge the in-Game Databases \n    tCreateAndMerge = {},\n}\n\nExampleContentPackDatabase.GetDatabaseConfig = function()\n    return tConfig\nend\n</code></pre></p> <p>This Lua script will be executed and the function GetDatabaseConfig called once during the Game Database merging process. It is still too early to have access to most of the game features, as the game data is still being loaded; however, this gives you the scaffolding to modify some of the game information without replacing the original files. </p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#game-database-files","title":"Game Database Files","text":"<p>The main Game Database Manager in Cobra Engine supports different methods to hold its data. While internally it creates a volatile SQLite database, some of the information it handles is saved as tables by their content providers. One of these examples is the <code>Island</code> Database Manager of Jurassic World Evolution 1 and 2. The <code>Island</code> data is not stored in any file and created ad-hoc in memory from a Lua table. Some other modules like the Buildings provider in the same title, stores all the building-related information in a SQLite database. These Game Databases have the extension <code>.fdb</code> and can be edited with any SQLite browser. Our recommendation is SQLiteStudio.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#modifying-existing-game-databases","title":"Modifying Existing Game Databases","text":"<p>This point is where the game is merging the content, and therefore it is asking to all Content Packs to provide them with any 'data' that needs to be added to the database. We can use this point in the game execution to modify or add existing data to the game, however; the data being process depends on the game title. </p> <p>For a quick test we can extract the FDB from its OVL, edit and modify the attributes we want, inject back in the OVL file using cobra-tools and save it back to its original file, but this change will stop working in the next update of the game when the files are replaced with their newer versions. </p> <p>Ideally we want our content to be merged to the original content. The overall process is to select which game FDB file(s) you want to modify, make a copy of it into your Content Pack folder, modify to whatever values you want and instruct how to load and merge this database file in our Databases.ExampleContentPackDatabase.Lua</p> <p>In the case of Jurassic World Evolution 2, the game defines the price for the different buildings in a database from its main Content Pack called: <code>Content0\\Main\\C0Buildings.fdb</code>. Extract this file and make a copy in our <code>ExampleContentPack\\Main\\</code>, and rename the file to <code>TestBuildings.fdb</code></p> <p>We now want to modify one of the entries in this database. Open the database, expand the table list and navigate to the table called 'Power'. This table defines how much power a building uses or produces. Lets change the power used by the Hatchery: - Browse the data of the table 'Power'. - Find the line that has PWR_Generator in the Building column.  - Edit the PowerOutput in that row to 300. - Commit and save the changes in the database.</p> <p>Now we need to instruct the game to load this file and merge its contents with the existing database. Back to your Databases.ExampleContentPack.lua it is time to add information to the tConfig table. Replace the previous tConfig Table with this one and save the lua file.</p> <pre><code>local tConfig = {\n    -- Tell the main Game Database controller to load the following FDB files\n    -- where sSymbol is the FDB name, and the key is the name we will use\n    -- to reference this FDB name. We are loading TestBuildings.fdb as 'TestBuildingsFile'.\n    -- You can load different tables at this point\n    tLoad = {\n        TestBuildingsFile = {\n            sSymbol = \"TestBuildings\"\n        }\n    },\n\n    -- Additionally, we need to tell the game to create the in-game runtime database\n    -- and merge its content. To interact with the database we need to specify the\n    -- tables to look from and the prepared\n    -- statements to use (the PSCollection name):\n    -- If the runtime database already exists, the current data will be\n    -- merged with the existing one based on the table/colum rules defined\n    -- in the database.\n    tCreateAndMerge = {\n        -- Define the new entry here. This Key will give the name to the table in the Game Database.\n        -- We are modifying the original database called 'Buildings' by the game created in content0.\n        -- The in-Game Databases can be found in the content0\\Init\\Databases.content0.lua file.\n        Buildings = {\n            -- Specify our merging content, we loaded as TestBuildingsFile before. You can merge\n            -- several databases here as long as they have the same structure. For now we just merge\n            -- our single file.\n            tChildrenToMerge = {\n                \"TestBuildingsFile\"\n            }\n        },\n    }\n}\n</code></pre> <p>Now we need to pack both the <code>Init</code> folder into Init.ovl and the <code>Main</code> folder into Main.ovl again and launch the game, the power generated by the backup generator has changed to the value of your choice.</p> <p>It is important to remove every entry in the new database that has not been modified and is not required, this will reduce merging errors.</p> <p>While this method works with FDB files, other databases do not store its data in a file, instead they are stored in a Lua table provided by the database script responsible for it. </p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#adding-custom-databases","title":"Adding Custom Databases","text":"<p>When writing a Content Pack at some point you might want to introduce your own database files too. The game engine supports that using a different scheme. This time we have to tell the Game Database that our database file needs to be added to the game and it will be the main content provider where other Content Packs can merge their information to.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#adding-the-fdb-files","title":"Adding the FDB Files","text":"<p>To add a custom database file to our ExampleContentPack mod, we first need to create the database. It needs to be a SQLite3 database and saved with the .fdb extension in the Main folder and we will name it <code>ExampleContent\\Main\\TestCustomData.fdb</code>. </p> <p>Open the database FDB file and for this example we will create a table called 'TestTable1' With three columns: - Column name: \"ID\", type integer, Primary Key, Unique, Not Null - Column name: \"Name\", type string - Column name: \"Value\", type string</p> <p>This SQL sentence will create the table for you: <pre><code>CREATE TABLE TestTable1 (\n    Id    INTEGER UNIQUE\n                  NOT NULL\n                  PRIMARY KEY,\n    Name  STRING,\n    Value STRING\n);\n</code></pre></p> <p>We want to have our table populated with some values, so lets go ahead an create a few entries, using IDs starting from 1001 (later we will query the table for these values). In this example I'll add the following entries: |  ID  | Name  |  Value | |------|-------|--------| | 1001 | Name1 | Value1 | | 1002 | Name2 | Value2 |</p> <p>Note: these values and Ids are not relevant, they are just to showcase the use of a custom database.</p> <p>Back to our <code>ExampleContentPack\\Init\\Databases.ExampleContentPack.lua</code> file, it is time to introduce the new FDB file in the game. Edit the lua file and modify the tConfig table to include the following:</p> <pre><code>local tConfig = {\n    -- Tell the main Game Database controller to load the following FDB files\n    -- where sSymbol is the FDB name, and the key is the name we will use\n    -- to reference this FDB name. We are loading TestBuildings.fdb as 'TestBuildingsFile'.\n    -- Additionally, we are loading our custom FDB file as well\n    tLoad = {\n        TestBuildingsFile = {\n            sSymbol = \"TestBuildings\"\n        },\n        TestCustomDataFile = {\n            sSymbol = \"TestCustomData\"\n        }\n    },\n\n    -- Additionally, we need to tell the game to create the in-game runtime database\n    -- and merge its content. To interact with the database we need to specify the\n    -- tables to look from and the prepared\n    -- statements to use (the PSCollection name):\n    -- If the runtime database already exists, the current data will be\n    -- merged with the existing one based on the table/colum rules defined\n    -- in the database.\n    tCreateAndMerge = {\n        -- Define the new entry here. This Key will give the name to the table in the Game Database.\n        -- We are modifying the original database called 'Buildings' by the game created in content0.\n        -- The in-Game Databases can be found in the content0\\Init\\Databases.content0.lua file.\n        Buildings = {\n            -- Specify our merging content, we loaded as TestBuildingsFile before. You can merge\n            -- several databases here as long as they have the same structure. For now we just merge\n            -- our single file.\n            tChildrenToMerge = {\n                \"TestBuildingsFile\"\n            }\n        },\n\n        -- Define the new entry here. This Key will give the name to the table in the Game Database.\n        -- This time are creating a new database instead of modifying an existing one, so the entry\n        -- will look a bit different.\n        -- ExampleTestData is the name of table the game will create for us.\n        ExampleTestData = {\n            -- Specify Which one of the database files is to be considered the first one\n            -- One to which other databases can merge to. We associated our custom FDB file \n            -- to the key: 'TestCustomDataFile'\n            FirstChild = \"TestCustomDataFile\"\n            -- Specify one or more Prepared Statement Collections to operate with\n            -- this database. For the game to access the data in the FDB file, it needs a set of \n            -- Prepared Statements. This list of statements will be associated to the table\n            -- internally by the Game Database\n            tCollections = {\"ExampleContentPackPSList\"},            \n            -- Additionally, we could just specify specific Prepared Statements to be assigned \n            -- to this database adding their names to the statements table.\n            -- tStatements = { \"PreparedStatementName\"}\n        }\n\n    }\n}\n</code></pre> <p>With this new config table in our database merging code, the game will load an FDB, assign it a table and associate the Prepared Statements with the database. But before we can use this new database, we need to create the Prepared Statement Collection.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#adding-a-prepared-statement-collection","title":"Adding a Prepared Statement Collection","text":"<p>Prepared Statements are predefined SQL queries to interact with a database. It can support any number of arguments and operate with many different tables. The only difference to raw SQL queries is that they have been predefined, they have type constrains in their arguments and are less prone to fail because they are not build randomly. They are static and can't be modified. </p> <p>During this example we have added a database with a table called 'TestTable1', with columns 'Id', 'name' and 'value'. We need to create a collection of Prepared Statements based on the interactions we expect to have with this database. For this example we will have: - A SQL Query to load all TestTable1 ID different values. It does not need arguments. - A SQL Query to find an ID based on the Name. It will need one argument of type String. - A SQL Query to find a Value based on an ID. It will need one argument of type Int. - A SQL Query to update a value based on an ID. It will need two arguments, Int for the ID and string for the new value.</p> <p>Cobra-tools treats PSCollections as an XML file, and therefore they are easy to craft manually with any editor. Based on the previous list of SQL queries, we will create the <code>ExampleContentPack\\Init\\ExampleContentPackPSList.pscollection</code> file and edit with a text editor. Add the following content to it:</p> <pre><code>&lt;PscollectionRoot game=\"Games.JURASSIC_WORLD_EVOLUTION_2\"&gt;\n    &lt;prepared_statements pool_type=\"4\"&gt;\n        &lt;preparedstatement&gt;\n            &lt;args /&gt;\n            &lt;statement_name&gt;GetAllIdFromTestTable1&lt;/statement_name&gt;\n            &lt;sql_query&gt;SELECT id FROM TestTable1;&lt;/sql_query&gt;\n        &lt;/preparedstatement&gt;\n        &lt;preparedstatement&gt;\n            &lt;args pool_type=\"4\"&gt;\n                &lt;arg arg_type=\"3\" arg_index=\"1\" /&gt;\n            &lt;/args&gt;\n            &lt;statement_name&gt;GetTestTable1IdFromName&lt;/statement_name&gt;\n            &lt;sql_query&gt;SELECT id from TestTable1 WHERE name=?1;&lt;/sql_query&gt;\n        &lt;/preparedstatement&gt;\n        &lt;preparedstatement&gt;\n            &lt;args pool_type=\"4\"&gt;\n                &lt;arg arg_type=\"0\" arg_index=\"1\" /&gt;\n            &lt;/args&gt;\n            &lt;statement_name&gt;GetTestTable1ValueFromId&lt;/statement_name&gt;\n            &lt;sql_query&gt;SELECT value from TestTable1 WHERE id=?1;&lt;/sql_query&gt;\n        &lt;/preparedstatement&gt;\n        &lt;preparedstatement&gt;\n            &lt;args pool_type=\"4\"&gt;\n                &lt;arg arg_type=\"0\" arg_index=\"1\" /&gt;\n                &lt;arg arg_type=\"3\" arg_index=\"2\" /&gt;\n            &lt;/args&gt;\n            &lt;statement_name&gt;SetTestTable1ValueForId&lt;/statement_name&gt;\n            &lt;sql_query&gt;UPDATE TestTable1 SET value=?2 WHERE id=?1;&lt;/sql_query&gt;\n        &lt;/preparedstatement&gt;\n&lt;/PscollectionRoot&gt;\n</code></pre> <p><code>arg_type</code> 0 indicates an integer value <code>arg_type</code> 2 indicates a float value <code>arg_type</code> 3 indicates a string value. <code>arg_index</code> is the order; <code>arg_index=\"1\"</code> belongs to the Prepared Statement parameter ?1, and so on.  </p> <p>We could add more SQL Queries to the PSCollection as we need. Some in-game databases have dozens of statements in their Prepared Statements collection, but for now as an example these will be enough.</p> <p>At this point we can re-pack our Init.ovl and Main.ovl files. Our Content Pack will load and modify the existing Buildings database, and add a custom FDB database to the game. All this happens during the Game Database bootstrap/initialization process. However, we are still unable to make use of our custom FDB data. Our Lua injection is happening too early in the database merging process and at this point probably not all the game tables have been populated with their final data.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#database-managers","title":"Database Managers","text":"<p>To provide the game with support for the different data, Content Packs can inject custom Database Managers into the main game. Each one of these managers will be responsible for their data, whether it is in a FDB file or a Lua table, or every other method available. The main game script will define a set of 'hardcoded' Database Managers it is expecting, however; additional Database Managers can be provided from a Content Pack. In this example we have added a custom FDB file to the game, now it is time to provide the game with access to this information through a custom Database Manager. </p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#creating-a-database-main-loader","title":"Creating a Database Main Loader","text":"<p>After the early initialization content merging process, the Game Database will later look for Content Pack Lua database controllers through its modular system. Each Content Pack can define one or more Database Managers but initially it will look for a default one. It is time we go back to our Main content folder and create the <code>ExampleContentPack\\Main\\Database.ExampleContentPackLuaDatabase.lua</code> file, with the following content: <pre><code>local global = _G\nlocal table = global.table\nlocal require = require\nlocal ExampleContentPackLuaDatabase = module(...)\n\n-- AddContentToCall is the hot-plug mechanism used by the Game Database to help Content Packs\n-- attach their own Database Managers to the game.\nExampleContentPackLuaDatabase.AddContentToCall = function(_tContentToCall)\n    -- We tell the Database Manager to load our custom Database Manager by its Lua name\n    -- You can add as many as you want, ideally separating each manager for each content type you add\n    table.insert(_tContentToCall, require(\"Database.ExampleContentDatabaseManager\"))\nend\n</code></pre></p> <p>With this file, the Game Database now Knows it needs to look for a file called: Database.ExampleContentDatabaseManager, so go ahead and create the <code>ExampleContentPack\\Main\\Database.ExampleContentDatabaseManager.lua</code> file, with the following content: <pre><code>-- This file is responsible of managing the data inside the TestCustomData.fdb and providing it to the game\nlocal global = _G\nlocal api = global.api\nlocal pairs = pairs\nlocal ipairs = ipairs\nlocal type = type\nlocal table = global.table\nlocal tostring = global.tostring\nlocal GameDatabase = require(\"Database.GameDatabase\")\nlocal ExampleContentDatabaseManager = module(...)\n\n--\n-- Initialization functions. These functions are called during the initialization process only\n--\n\n-- This method will be called when our manager gets initialized, early in the game launch after\n-- all data has been merged for all the Content Packs. This method allows our manager to know\n-- the database is getting initialized.\nExampleContentDatabaseManager.Init = function()\n\nend\n\n-- This table contains the list of functions our module wants to add to the Game Database.\nExampleContentDatabaseManager.tDatabaseFunctions = {}\n\n-- This method will be called when our manager gets initialized to inject custom functions \n-- in the Game Database. These functions will be available for the rest of the game Lua modules.\nExampleContentDatabaseManager.AddDatabaseFunctions = function(_tDatabaseFunctions)\n    for sMethod,fnMethod in pairs(ExampleContentDatabaseManager.tDatabaseFunctions) do\n        _tDatabaseFunctions[sMethod] = fnMethod\n    end\nend\n\n-- This method will be called after our manager gets initialized, all Database and Player methods have \n-- been added to the main Game Databases.\nExampleContentDatabaseManager.Setup = function()\n\nend\n\n--\n-- Database active functions. These functions are optional and can be called while our Database Manager is active.\n--\n-- Nothing included yet.\n\n\n--\n-- De-initialization functions. These functions are called during the shutdown or restart processes only\n--\n\n-- This method will be called when the Game Database is shutting down for re-initialization. It is a soft Re-Init\n-- of the database. We don't need to close or free resources if we don't want, but remember we have them open when\n-- the Game Database calls our :Init() function again.\nExampleContentDatabaseManager.ShutdownForReInit = function()\n\nend\n\n-- This method will be called when the Game Database is shutting down and we need to close any \n-- or free any resource we have open. The module will be unloaded after.\nExampleContentDatabaseManager.Shutdown = function()\n\nend\n</code></pre></p> <p>The file above is a good template for a Database Manager. Database Managers can have more hooks used by the game, but for our current purpose we will limit the template to what we need. This file will be loaded by the Database Manager and the different methods will get called in the following order:</p> <ol> <li><code>Setup()</code></li> <li><code>AddDatabaseFunctions()</code></li> <li><code>Init()</code></li> </ol>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#adding-gamedatabase-functions","title":"Adding GameDatabase Functions","text":"<p>It is time to add our custom database functions to the game. We created SQL queries above to:</p> <ol> <li>Get all TestTable1 IDs</li> <li>Look up a TestTable1 ID based on a name</li> <li>Find a value based on a TestTable1 ID</li> <li>Update an entry value for a TestTable1 ID</li> </ol> <p>We will create four functions to provide this functionality through the Game Database.</p> <p>Start with populating the <code>ExampleContentDatabaseManager.tDatabaseFunctions</code> table in the <code>ExampleContentPack\\Main\\Database.ExampleContentDatabaseManager.lua</code> file with the following content: <pre><code>ExampleContentDatabaseManager.tDatabaseFunctions = {\n    -- This function will return all the Ids inside TestTable1 of TestCustomData.fdb\n    GetAllTestDataIds = function()\n        return ExampleContentDatabaseManager._GetAllTestDataIds()\n    end,\n    -- This function will return the Id for a name inside TestTable1 of TestCustomData.fdb\n    GetTestDataIdFromName = function(_sName)\n        return ExampleContentDatabaseManager._GetTestDataIdFromName(_sName)\n    end,\n    -- This function will return the value for an Id inside TestTable1 of TestCustomData.fdb\n    GetTestDataValueFromId = function(_nId)\n        return ExampleContentDatabaseManager._GetTestDataValueFromId(_nId)\n    end,\n    -- This function will set the value for an Id inside TestTable1 of TestCustomData.fdb\n    SetTestDataValueFromId = function(_nId, _sValue)\n        return ExampleContentDatabaseManager._SetTestDataValueFromId(_nId, _sValue)\n    end\n}\n</code></pre> Each one of these GameDatabase functions calls another function (defined below) to perform each custom database query through the Prepared Statements we added before. </p> <p>The functions called by the above GameDatabase functions will be defined in the following code:</p> <pre><code>-- The following code utilizes the Game Database Lua component to perform SQL queries on the Game Database.\n-- Read each one to understand how to use the Prepared Statements in-game interface when interacting with a database.\n--\n-- Custom Database API\n--\n\nExampleContentDatabaseManager._GetAllTestDataIds() = function\n    local result = nil\n    local database = global.api.database\n\n    -- We called our database 'ExampleTestData' in the Databases.ExampleContentPack.Lua file\n    -- We created a Prepared Statement called 'GetAllIdFromTestTable1'\n    local cPSInstance = database.GetPreparedStatementInstance(\"ExampleTestData\", \"GetAllIdFromTestTable1\")\n    if cPSInstance ~= nil then\n        database.BindComplete(cPSInstance)\n        database.Step(cPSInstance)\n        result = database.GetAllResults(cPSInstance, false)\n    end\n\n    return result\nend\n\n-- This function will search the database for rows with the name = _sName and return\n-- the first match. _sName has to be a string.\nExampleContentDatabaseManager._GetTestDataIdFromName  = function(_sName)\n    local result = nil\n    local database = global.api.database\n\n    -- We called our database 'ExampleTestData' in the Databases.ExampleContentPack.Lua file\n    -- We created a Prepared Statement called 'GetTestTable1IdFromName'\n     local cPSInstance = database.GetPreparedStatementInstance(\"ExampleTestData\", \"GetTestTable1IdFromName\")\n     if cPSInstance ~= nil then\n        database.BindParameter(cPSInstance, 1, _sName)\n        database.BindComplete(cPSInstance)\n        database.Step(cPSInstance)\n        local tRows = database.GetAllResults(cPSInstance, false)\n        result = tRows[1] or nil\n    end\n\n    return result\nend\n\n-- This function will search the database for rows with the Id = _sId and return\n-- the first match. _sId has to be a number.\nExampleContentDatabaseManager._GetTestDataValueFromId = function(_nId)\n    local result = nil\n    local database = global.api.database\n\n    -- We called our database 'ExampleTestData' in the Databases.ExampleContentPack.Lua file\n    -- We created a Prepared Statement called 'GetTestTable1ValueFromId'\n     local cPSInstance = database.GetPreparedStatementInstance(\"ExampleTestData\", \"GetTestTable1ValueFromId\")\n     if cPSInstance ~= nil then\n        database.BindParameter(cPSInstance, 1, _sId)\n        database.BindComplete(cPSInstance)\n        database.Step(cPSInstance)\n        local tRows = database.GetAllResults(cPSInstance, false)\n        result = tRows[1] or nil\n    end\n\n    return result\nend\n\nExampleContentDatabaseManager._SetTestDataValueFromId = function(_nId, _sValue)\n    local result = nil\n    local database = global.api.database\n\n    -- Before we try to change the database we need to enable writing mode to it.\n    -- By default all databases are Read-Only after they are being loaded and merged.\n    database.SetReadOnly(\"ExampleTestData\", false)\n\n    -- We called our database 'ExampleTestData' in the Databases.ExampleContentPack.Lua file\n    -- We created a Prepared Statement called 'SetTestTable1ValueForId'\n     local cPSInstance = database.GetPreparedStatementInstance(\"ExampleTestData\", \"SetTestTable1ValueForId\")\n     if cPSInstance ~= nil then\n        database.BindParameter(cPSInstance, 1, _sId)\n        database.BindParameter(cPSInstance, 2, _sName)\n        database.BindComplete(cPSInstance)\n        database.Step(cPSInstance)\n        local tRows = database.GetAllResults(cPSInstance, false)\n        result = tRows[0] or nil\n    end\n\n    -- Before returning, lock the database again.\n    database.SetReadOnly(\"ExampleTestData\", true)\n\n    return result\nend\n</code></pre> <p>With this finished, re-pack the Init.ovl and Main.ovl files and try again. We have modified the Game Database API, with newly created functions provided by our own custom Database Manager module.</p> <p>Once our module has been initialized, our API methods will be added to the main Game Database, and any module can use them with the following code snippet: <pre><code>local GameDatabase = require(\"Database.GameDatabase\")\nlocal tIds = GameDatabase.GetAllTestDataIds()\nlocal tId  = GameDatabase.GetTestDataIdFromName(\"Name1\")\n</code></pre></p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Databases/#modifying-other-content-pack-databases","title":"Modifying Other Content Pack Databases","text":"<p>We have seen before how to merge our custom content data into another Content Pack database. However due to the merging process, another Content Pack can overwrite our changes if it is loaded after our Content Pack. With the use of Prepared Statements it is possible to have access to other databases after the content merging process has been completed. </p> <p>Initially we modified the Buildings module increasing the power produced by the backup generator. We can do it again, but this time without needing any extra FDB file.</p> <p>First we need a custom Prepared Statement to modify the appropriate table. So we start by creating a new Prepared Statement Collection called <code>ExampleContentPack\\Init\\ExampleBuildingsPSList.pscollection</code> file and editing with a text editor. Add the following content to it:</p> <pre><code>&lt;PscollectionRoot count=\"1\" game=\"Games.JURASSIC_WORLD_EVOLUTION_2\"&gt;\n    &lt;preparedstatement arg_count=\"2\"&gt;\n        &lt;args pool_type=\"4\"&gt;\n            &lt;arg arg_type=\"3\" arg_index=\"1\" /&gt;\n            &lt;arg arg_type=\"0\" arg_index=\"2\" /&gt;\n        &lt;/args&gt;\n        &lt;statement_name&gt;SetPowerOutputForBuildingName&lt;/statement_name&gt;\n        &lt;sql_query&gt;UPDATE Power SET PowerOutput=?2 WHERE Building=?1;&lt;/sql_query&gt;\n    &lt;/preparedstatement&gt;\n&lt;/PscollectionRoot&gt;\n</code></pre> <p>Now, back to our <code>ExampleContentPack\\Main\\Database.ExampleContentDatabaseManager.lua</code>, we will modify our <code>Setup()</code> to update the Building's power after the merging process has completed. It should look like this:</p> <pre><code>-- This method will be called after our manager gets initialized, all Database and Player methods have \n-- been added to the main Game Databases.\nExampleContentDatabaseManager.Setup = function()\n    -- Get access to the Game Database interface\n    local database = global.api.database\n\n    -- Before we try to change the database we need to enable writing mode to it.\n    -- By default all databases are Read-Only after they are being loaded and merged.\n    database.SetReadOnly(\"Buildings\", false)\n\n    -- We need to bind our new Prepared Statement Collection to the Buildings database before\n    -- we can use any of its statements.\n    local bSuccess = database.BindPreparedStatementCollection(\"Buildings\", \"ExampleBuildingsPSList\")\n    if bSuccess == 0 then return nil end\n\n    -- We created a Prepared Statement called 'SetTestTable1ValueForId'\n    local cPSInstance = database.GetPreparedStatementInstance(\"Buildings\", \"SetPowerOutputForBuildingName\")\n    if cPSInstance ~= nil then\n        database.BindParameter(cPSInstance, 1, \"PWR_Generator\") -- first argument, string\n        database.BindParameter(cPSInstance, 2, 123)             -- second argument, number\n        database.BindComplete(cPSInstance)\n        database.Step(cPSInstance)\n        database.GetAllResults(cPSInstance, false)\n    end\n\n    -- Before returning, lock the database again\n    database.SetReadOnly(\"Buildings\", true)\nend\n</code></pre> <p>Now re-pack both the Init.ovl and the Main.ovl files again, and the Backup Generator will always produce 123 units regardless of the value in any of the Building databases loaded during the merging process. The same Prepared Statement can be used to modify other building power outputs; just run the query several times with different values. Consider creating a function in the main database controller to clean up and centralize your code.</p> <p>We haven't finished with the Game Databases yet, but the next topic covers a completely different area of database controllers and therefore needs to be split from this tutorial.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/","title":"Game Managers","text":"<p>Note</p> <p>The functionality explained here requires ACSE installed in the game to work.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#introduction","title":"Introduction","text":"<p>Game managers are Lua files that when injected, can communicate and use existing game API, modify or add new functionality or even gameplay to a Cobra Engine game. A game manager is similar to a singleton Monobehaviour in Unity. It is a special class Lua file with different functions called by the Cobra Engine on different steps of the game including initialization, shutdown, or every time a frame is being rendered. If you need to execute your custom Lua code everytime a game is loaded, an action is performed or a frame is rendered you definitelly need a custom Manager.</p> <p>Managers are not tied to entities, meaning there can be only one Manager instance running at any given time.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#environments","title":"Environments","text":"<p>Game managers run inside a game Environment. An Environment is a Lua context responsible for loading managers (could be in an specific order) and handles all the manager life cycle management. Environments are loaded by the running world script running the loaded world. In other words: there are multiple game environments, and managers need to opt-in to be loaded. Cobra Engine usually has two main Environments (or World scripts): - Start screen Environment: used during the main menu screen (globe screen on PZ, game selection UI in JWE, etc). - Park environment: used during the actual playable game (a Zoo in PZ or an Island in JWE).</p> <p>There could be additional game Environments (e.g. the Species Viewer mode in JWE2 uses a custom Environment). Each Environment will include a different set of Managers (e.g. a Park environment will need animal control managers, but not the main menu UI). Regardless the environment the Manager is loaded into, it usually performs the same steps and requires a very specific set of functions to interact with the game. Because these two environments are so different, you usually would like to have a Park Manager And a Start screen Manager in case you need both, otherwise just include your Manager in the environment in which you will use it, you don't need to include your Managers in all the environments.</p> <p>The environments are defined by the game and the game main script uses one environment or another depending on the world being loaded. It is strongly recommended to not modify the existing environments manually (any Environments.*.lua file) and use ACSE to inject your manager file and prevent breaking other mods.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#cobra-game-manager-structure","title":"Cobra Game Manager Structure","text":"<p>A game manager for Cobra Engine can be templated as the following:</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    Managers.CustomManager.lua\n--/  @author  Inaki\n--/  @version 1.0\n--/\n--/  @brief  Boilerplate template for a park manager script\n--/  @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global = _G\nlocal api = global.api\nlocal pairs = global.pairs\nlocal require = global.require\nlocal module = global.module\nlocal Object = require(\"Common.object\")\nlocal Mutators = require(\"Environment.ModuleMutators\")\n\n--/ Main class definition\nlocal CustomManager = module(..., Mutators.Manager())\n\n--\n-- @Brief Init function for this manager\n-- @param _tProperties  a table with initialization data for all the managers.\n-- @param _tEnvironment a reference to the current Environment \n--\n-- The Init function is the first function of the manager being called by the game.\n-- This function is used to initialize all the custom data required, however at this\n-- stage the rest of the managers might not be available.\n--\nCustomManager.Init = function(self, _tProperties, _tEnvironment)\n    api.debug.Trace(\"CustomManager:Init()\")\nend\n\n--\n-- @Brief Activate function for this manager\n--\n-- Activate is called after all the Managers of this environment have been initialised,\n-- and it is safe to assume that access to the rest of the game managers is guaranteed to\n-- work.\n--\nCustomManager.Activate = function(self)\n    api.debug.Trace(\"CustomManager:Activate()\")\nend\n\n--\n-- @Brief Update function for this manager\n--\n-- Advance is called on every frame tick.\n--\nCustomManager.Advance = function(self, _nDeltaTime, _nUnscaledDeltaTime)\n    --api.debug.Trace(\"CustomManager:Advance()\")\nend\n\n--\n-- @Brief Deactivate function for this manager\n--\n-- Deactivate is called when the world is shutting down or closing. Use this function\n-- to perform any deinitialization that still requires access to the current world data\n-- or other Managers.\n-- \nCustomManager.Deactivate = function(self)\n    api.debug.Trace(\"CustomManager:Deactivate()\")\nend\n\n--\n-- @Brief Shutdown function for this manager\n--\n-- Shutdown is called when the current world is shutting down.\n--\nCustomManager.Shutdown = function(self)\n    api.debug.Trace(\"CustomManager:Shutdown()\")\nend\n\n--/ Validate class methods and interfaces, the game needs\n--/ to validate the Manager conform to the module requirements.\nMutators.VerifyManagerModule(CustomManager)\n</code></pre> <p>Not all the Manager calls are required, in fact, none of them are required. You could have a Manager that only runs a piece of code on the Init() step of the world loading so you can just implement Init() and remove all the other functions. Regardless of how simple your Manager is, it still needs to be validated as a Manager at the end by the Mutators object or it will not load.</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#exporting-methods-manager-interface","title":"Exporting Methods: Manager Interface","text":"<p>The basic Manager template showcased in the previous point is so simple, no other Manager in the game can interact with it, which is appropriate for many cases. However, it is common for a Manager to allow other game areas to interact with it. Imagine your Manager has the ability to open or close a park (allowing guests to come in or not), you might want this action to be exposed to other Managers so they can just use it without having to implement it. Another good example is the Weather storm manager: it includes code to start/stop storms based on certain conditions; however, it also allows other Managers to request a Storm starting or stopping at any given time. This functionality is achieved through Interfaces.</p> <p>An interface is another script that defines what parts of a Manager will be exposed publicly to be used by other game Managers. An interface is only required if you want your Manager code to be exposed to other game elements. The use of interfaces is encouraged to prevent two different managers trying to control the same element of the game. Imagine the case of the door, where one manager has been instructed to Open the door and another one has been instructed to do the opposite.</p> <p>Lets have a look at the CameraShake manager from JWE2. This manager adds the ability to shake the camera (this Manager exists in JWE2) for close dinosaur stomps, weather events, etc. This is preferred to having multiple scripts trying to shake the camera at the same time, if any other manager needs the effect, it can ask the CameraShake manager to do that instead. To allow this functionality, the CameraShake manager provides an Interface that looks like this:</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    Interfaces.ICameraShakeManager.lua\n--/  @author  Frontier\n--/\n--/  @brief  Interface file for the CameraShake Manager \n--\nlocal Mutators    = require(\"Common.mutators\")\nlocal Interface   = module(..., Mutators.Interface)\nInterface.Methods = {\n    \"ShakeCamera\", \n    \"SetPeriodicShakeParams\"\n}\nMutators.VerifyInterfaceModule(Interface)\n</code></pre> <p>This interface is exporting two methods, called: ShakeCamera (to start the shaking action) and SetPeriodicShakeParams (to configure how the shaking will perform).</p> <p>Creating the interface file is not the only thing required for a Manager to export functions to the game. The interface also needs to be defined in the Manager file:</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    Managers.CameraShakeManager.lua\n--/  @author  Frontier\n--/\n--/  @brief  Interface file for the CameraShake Manager \n--\nlocal global = _G\nlocal api = global.api\nlocal pairs = pairs\nlocal math = global.math\nlocal table = require(\"Common.tableplus\")\nlocal Vector3 = require(\"Vector3\")\nlocal Object = require(\"Common.object\")\nlocal mathUtils = require(\"Common.MathUtils\")\nlocal Mutators = require(\"Environment.ModuleMutators\")\n\n-- Define our Manager class using a specific interface file\nlocal CameraShakeManager = module(..., Mutators.Manager(\"Interfaces.ICameraShakeManager\"))\n\n-- ... rest of the file follows\n</code></pre> <p>That is the difference between a Manager with and without and interfaces, the interface file needs to be specified on the module creation code. With this parameter, during the validation of the Manager, the game will check that the two exposed functions: \"ShakeCamera\" and \"SetPeriodicShakeParams\" exist in the Manager class. In that file (Managers.CameraShakeManager.lua) you will find the following code:</p> <pre><code>CameraShakeManager.ShakeCamera = function(self, _tParams)\n-- ...\nend\n\nCameraShakeManager.SetPeriodicShakeParams = function(self, _tParams)\n-- ...\nend\n</code></pre> <p>To finalize this point, if we want to expose functions to other part of the game, we will need to create an interface. So, the next question is then: how do we use an existing interface? </p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#using-manager-interfaces","title":"Using Manager Interfaces","text":"<p>If we want to use some other Manager interface, all we need to do is request the interface from the running Environment. The Environment class is responsible for the life cycle all the Managers present in the game mode we are in:</p> <pre><code>  -- the _tEnvironment table is passed to the manager during the Init() call.\n  local iCameraShakeManager = _tEnvironment:RequestInterface(\"Interfaces.ICameraShakeManager\")\n\n  -- Now we just need to call the exported method with the appropriate expected data. Note: the\n  -- data to call each exported method is different and requires looking at the inputs of the function \n  -- we are calling.\n  iCameraShakeManager:ShakeCamera( tCameraShakeData )\n</code></pre> <p>The current Game managers already export a lot of interesting functions you can use if you just request the corresponding interfaces. These functions include full control of the playing Cinematic video, communications, popups, full access to the Park rating, etcetera. Before going into coding any of this logic, first find out what Manager is responsible for what functionality, and then see what is exposed in the manager interface that you can use in your own scripts. </p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#complex-manager-initialization","title":"Complex Manager Initialization","text":"<p>Sometimes, especially when a Manager depends on other Managers it is better to instruct the game to load your Manager in an specific order. This is accomplished with the addition of some Manager initialization data that will ensure any required dependency is loaded before your own Manager. This order affects not only the loading but also the order in which every class function is executed. If you need to update some data in your Manager only After the park rating has been updated, then you definitely want to force the ParkRatingManager to load before your own Manager.</p> <p>A good example for this particular case is the Ingen Database UI Manager of JWE2. This manager is responsible for preparing the data to be displayed in the Ingen Database tab, however this information is different for each user because it depends on a) Gene unlocks achieved by the player, b) the current techtree defined for the game. This is why, the IngenDatabaseUIManager Manager specifies the following phase ordering and requirements:</p> <pre><code>-- ..\n-- Define this Manager class using a custom Interface:\nlocal InGenDatabaseUIManager = module(..., Mutators.Manager(\"Interfaces.IInGenDatabaseUIManager\"))\n\n-- Execute our Init() function after Managers.GeneLibraryManager:Init()\nInGenDatabaseUIManager.PhaseDependencies = {\n  Init = {\n     \"Managers.GeneLibraryManager\"\n  }\n}\n\n-- Execute our Init() function after Managers.TechTreeManager:Init() if possible\n-- Execute our Activate() function after Managers.TechTreeManager:Activate() if possible\nInGenDatabaseUIManager.OptionalPhaseDependencies = {\n  Init = {\n    \"Managers.TechTreeManager\"\n  }, \n  Activate = {\n    \"Managers.TechTreeManager\"\n  }\n}\n</code></pre> <p>Using the PHaseDependencies table, a Manager can instruct the Environment to execute its functions (e.g. Init or Activate) after the other Managers functions have been executed (in this case GeneLibraryManager and TechTreeManager). While the OptionalPhaseDependencies is not an enforced execution order, it will be honored by the game if it is defined and possible. This is because in some cases, other Managers might have other phase dependencies and circular references can ocurr at some point (Manager A requiring Manager B and viceversa).</p>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#injecting-managers","title":"Injecting Managers","text":"<p>As mentioned before, the current method to inject Managers in the game is through ACSE. You can still edit existing Managers in the game through the normal editing process using Cobra Tools.</p> <p>ACSE needs to know what environment you want your Managers to be injected into. ACSE has three different methods to add Managers, two of them are specific for the main common Environments (Start Screen and Park), and the third allows any other Environment specified.</p> <p>This is a code snippet to add Managers with ACSE, and can be pasted in any of the Database Lua scripts of your mod (ACSE will find them and use them):</p> <pre><code>-- List of custom managers to force injection on the starting screen\nYourModLoader.tStartScreenManagers = {\n    [\"Managers.MyCustomStartManager\"] = { }, -- Add your custom settings inside the table.\n}\n\n-- @brief Add our custom Manager to the starting screen\nYourModLoader.AddStartScreenManagers = function(_fnAdd)\n    local tData = YourModLoader.tStartScreenManagers\n    for sManagerName, tParams in pairs(tData) do\n        _fnAdd(sManagerName, tParams)\n    end\nend\n\n-- List of custom managers to force injection on a park\nYourModLoader.tParkManagers = {\n    [\"Managers.MyCustomParkManager\"] = { },  -- Add your custom settings inside the table.\n}\n\n-- @brief Add our custom Manager to the starting screen\nYourModLoader.AddParkManagers = function(_fnAdd)\n    local tData = YourModLoader.tParkManagers\n    for sManagerName, tParams in pairs(tData) do\n        _fnAdd(sManagerName, tParams)\n    end\nend\n</code></pre> <p>Usually this is enough to have your Managers added to the game. For the case where you want your Manager added to a different environment, you can use the following piece of code:</p> <pre><code>-- List of custom managers to force injection on a custom Environment\nYourModLoader.tManagers = {\n    [\"Environments.WhateverEnvironment\"] = {\n        [\"Managers.CustomEnvironmentManager\"] = {},\n    },\n}\n\n-- @brief Add our custom Manager to the different environments\nYourModLoader.AddManagers = function(_fnAdd)\n    local tData = YourModLoader.tManagers\n    for sManagerName, tParams in pairs(tData) do\n        _fnAdd(sManagerName, tParams)\n    end\nend\n</code></pre>"},{"location":"Guides/ACSE/Scripting-Guide/Game-Managers/#argument-passing","title":"Argument Passing","text":"<p>The Manager gets initialized by the Environment through the <code>Init()</code> function like so:</p> <pre><code>CustomManager.Init = function(self, _tProperties, _tEnvironment)\n-- ...\n</code></pre> <p>The <code>_tProperties</code> attribute used during the <code>Init()</code> call correspond to whatever settings you used to inject the Manager through ACSE. If this was your ACSE Manager definition:</p> <pre><code>YourModLoader.tStartScreenManagers = {\n    [\"Managers.MyCustomStartManager\"] = { \n       bBooleanValue = false, \n       sCustomString = \"Testing String\",\n    },\n}\n</code></pre> <p>You will receive these parameters as <code>_tProperties</code> when the Manager gets initialized. the <code>_tProperties</code> table allows to have functionality enabled or disabled specifically for each different environment (or game).</p>"},{"location":"Guides/ACSE/Scripting-Guide/LuaDatabase-Prefabs/","title":"LuaDatabase and Prefabs","text":"<p>While there are multiple ways to achieve the same goal (having your mod running flawlesly in the game), the way you interact with ACSE is totally up to you. We have however defined a 'best practice' for mods when you interact with ACSE to make sure we can guarantee compatibility with other tools moving forward.</p>"},{"location":"Guides/ACSE/Scripting-Guide/LuaDatabase-Prefabs/#checking-acse-is-present-in-the-game","title":"Checking ACSE is present in the game.","text":"<p>If you mod depends on ACSE, to avoid the game crashing it is recommended to test the right version of ACSE is installed. You can just simply ignore all your mod loading steps if ACSE is not present, or even show a prompt to the user to inform ACSE is needed to use your mod. This is a template for JWE2.</p> <p>If your mod provides custom FDBs to the game, first you'll need to make sure these FDBs are not loaded. Your Init/Databases.YOURMODNAME.lua file should look like this (the .... indicates this is your own content and change from mod to mod):</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    Databases.YOURMODNAME.lua\n--/  @author  yourself\n--/  @version 1.0\n--/\n--/  @brief  Defines additional FDB configuration. \n--/          Requires ACSE &gt; 0.641 to work due to add custom prefabs.\n--/\n--/  @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global = _G\n\n--/ Create the custom module for the package Init.\nlocal YOURMODNAMEDatabaseConfig = module(...)\n\n--\n-- Define the databases to be merged and the merging rules\n-- \nYOURMODNAMEDatabaseConfig.tConfig = {\n\n    -- Load our Paths database\n    tLoad = {\n         ....\n    },\n\n    -- Merge with the existing Paths database.\n    tCreateAndMerge = {\n         ....\n    }\n\n}\n\n-- @brief GameDatabase hook to add load and merge custom databases\nYOURMODNAMEDatabaseConfig.GetDatabaseConfig = function()\n\n  -- Prevent the inclusion of this assets if ACSE &lt;= 0.641 because\n  -- prefab support wasn't included until later versions.\n  if not global.api.acse or global.api.acse.versionNumber &lt; 0.641 then\n    return {}\n  else \n    return YOURMODNAMEDatabaseConfig.tConfig\n  end\n\nend\n</code></pre> <p>This change will prevent your FDBs being added to the game unless the right version of ACSE is installed. The same way, we now have to prevent the Prefabs and other UI information being added to the game. The next file we need to touch is your mod LuaDatabase.lua (Main/YOURMODNAMELuaDatabase.lua), that should look like this (the .... indicates this is your own content and change from mod to mod): </p> <pre><code>--\n-- @brief Informs the main game database about custom databases provided by this content pack\n-- @param _tContentToCall (table) table of additional database modules provided.\n--\nYOURMODNAMELuaDatabase.AddContentToCall = function(_tContentToCall)\n\n    -- Verify the game environment complies with the requirements before adding our gameplay items.\n    if not api.acse or api.acse.versionNumber &lt; 0.641 then\n        -- Note: Push/Pop user messages is only available in JWE1 and JWE2 games. \n        api.game.PushUserMessage(\n            \"[STRING_LITERAL:Value='The YOURMODNAME Mod requires ACSE 0.641\\n or greater installed and has been disabled.']\", nil\n        )\n        return\n    end \n\n    -- Add these module to the game database list.\n    -- Continue your normal loading here.\n    table.insert(\n    _tContentToCall,\n    require(\"Database.YOURMODNAMEInGenDatabaseData\")\n    )\n\n    table.insert(\n    _tContentToCall,\n    require(\"Database.YOURMODNAMEPrefabData\")\n    )\n\n    table.insert(\n    _tContentToCall, \n    require(\"Database.YOURMODNAMEtechtreeData\") \n    )\nend\n</code></pre>"},{"location":"Guides/ACSE/Scripting-Guide/LuaDatabase-Prefabs/#the-lua-prefabs","title":"The Lua prefabs","text":"<p>Up until now have been organizing prefabs in a Lua table and feeding them to ACSE through that function from a custom .lua file. While this has its pros and cons, it prevents using the prefabs from outside of this massive .lua file. The suggested method is to separate each prefab in its own file from now on.</p> <p>This is what a mod would loook like in its prefab data definition: <pre><code>--[[\nRename YOURMODNAME into the name of your folder\nRename SPECIESNAME into the codename of your species\nNOTE: Both renames are Case-Sensitive!\n]]--\n\nlocal global = _G\nlocal api = global.api\nlocal require = global.require\nlocal pairs = global.pairs\nlocal Vector2 = require(\"Vector2\")\nlocal Vector3 = require(\"Vector3\")\nlocal YOURMODNAMEPrefabData = module(...)\n\nYOURMODNAMEPrefabData.tPrefabs = {\n   -- A massive confusing unorganized table of data\n   .....\n}\n\nYOURMODNAMEPrefabData.AddLuaPrefabs = function(_fnAdd)\n    for _, tData in global.ipairs(YOURMODNAMEPrefabData.tPrefabs) do\n        for sPrefabName, tParams in global.pairs(tData) do\n            _fnAdd(sPrefabName, tParams)\n        end\n    end\nend\n</code></pre></p> <p>In this process we will move the prefabs out of the the database.YOURMODNAMEPrefabData.lua into single files. As a consequence, the table inside this file (and all the problems this has created) will be gone. Instead, we'll copy/paste the content of each prefab into its own file now.</p> <p>First, we'll define a template for every new prefab: <pre><code>-----------------------------------------------------------------------\n--/  @file    PREFABNAME.lua\n--/  @author  Yourself\n--/  @version 1.0\n--/\n--/  @brief  Defines an ACSE prefab\n--/\n--/  @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global  = _G\nlocal api     = global.api\nlocal require = global.require\nlocal pairs   = global.pairs\nlocal ipairs  = global.ipairs\n\nlocal PREFABNAME = module(...)\n\n-- PropTool uses GetRoot to build the inject the prefabs in ACSE\nPREFABNAME.GetRoot = function()\n    -- Your prefab information goes in here\n    return {}\nend \n\n-- Relay on the current entity API to generate the complete prefab\nPREFABNAME.GetFlattenedRoot = function()\n    local tPrefab = api.entity.CompilePrefab( PREFABNAME.GetRoot(), 'PREFABNAME')\n    return api.entity.FindPrefab('PREFABNAME')\nend\n\nreturn PREFABNAME\n</code></pre></p> <p>Save this template in Main/PREFABNAME.lua (add as many as prefabs in your mod).</p> <p>This template should allow for an easy search and replace of PREFABNAME with the actual name of the prefab. You need to replace PREFABNAME with the final name of the prefab, even in the file name. For example, if your mod defines 3 prefabs (MonolophosaurusDinoFootPrint, Monolophosaurus and Monolophosaurus_01) you need 3 lua files in Main: - Main/MonolophosaurusDinoFootPrint.lua - Main/Monolophosaurus.lua - Main/Monolophosaurus_01.lua</p> <p>To understand what we need to move to these files, I'll start with the footprint that is small enough to see the changes.</p> <p>Regardless if you have ordered the prefabs in this table or not, I'll hightlight was is important to extract. This is what the Database.YOURMODNAMEPrefabData.lua file uses to look like. There could be more or less {} around your data, but in overall will just be a list of PrefabName = PrefabData:</p> <p><pre><code>YOURMODNAMEPrefabData.tPrefabs = {\n\n    MonolophosaurusDinoFootPrint = {\n        Prefab = 'DinoFootprintTheropods',\n        Properties = {\n            Size = {\n                Default = vec3_const(0.35, 0.35, 0.35)\n            }\n        }   \n    },\n        ....\n</code></pre> In this example, consider the = sign,  MonolophosaurusDinoFootPrint is the prefab name, and everything on the right of the sign is the 'data': <pre><code>  {\n     Prefab = 'DinoFootprintTheropods',\n     Properties = {\n       Size = {\n           Default = vec3_const(0.35, 0.35, 0.35)\n       },\n     }  \n  }\n</code></pre> You have to be aware of the opening and closing keys {} because we need to copy all this data into the new prefab template.lua file. This is who it would look like: <pre><code>-----------------------------------------------------------------------\n--/  @file    MonolophosaurusDinoFootPrint.lua\n--/  @author  Yourself\n--/  @version 1.0\n--/\n--/  @brief  Defines an ACSE prefab\n--/\n--/  @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global  = _G\nlocal api     = global.api\nlocal require = global.require\nlocal pairs   = global.pairs\nlocal ipairs  = global.ipairs\nlocal Vector2 = require(\"Vector2\")\nlocal Vector3 = require(\"Vector3\")\n\nlocal MonolophosaurusDinoFootPrint = module(...)\n\n-- PropTool uses GetRoot to build the inject the prefabs in ACSE\nMonolophosaurusDinoFootPrint.GetRoot = function()\n    -- Your prefab information goes in here\n    -- paste the data after this return keyword\n    return \n    {\n       Prefab = 'DinoFootprintTheropods',\n       Properties = {\n         Size = {\n             Default = vec3_const(0.35, 0.35, 0.35)\n         },\n       }    \n    }\nend \n\n-- Relay on the current entity API to generate the complete prefab\nMonolophosaurusDinoFootPrint.GetFlattenedRoot = function()\n    local tPrefab = api.entity.CompilePrefab( MonolophosaurusDinoFootPrint.GetRoot(), 'MonolophosaurusDinoFootPrint')\n    return api.entity.FindPrefab('MonolophosaurusDinoFootPrint')\nend\n\nreturn MonolophosaurusDinoFootPrint\n</code></pre> It is strongly recommended to use a Lua beautifier to make sure the code formatting is readable and you can check if there are any errors.</p> <p>Now need to repeat the same process with the other two prefabs, in this example: Monolophosaurus and Monolophosaurus_01. I'll include the Monolophosaurus_01.lua as a guide too:</p> <pre><code>-----------------------------------------------------------------------\n--/  @file    Monolophosaurus_01.lua\n--/  @author  Yourself\n--/  @version 1.0\n--/\n--/  @brief  Defines an ACSE prefab\n--/\n--/  @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global  = _G\nlocal api     = global.api\nlocal require = global.require\nlocal pairs   = global.pairs\nlocal ipairs  = global.ipairs\nlocal Vector2 = require(\"Vector2\")\nlocal Vector3 = require(\"Vector3\")\n\nlocal Monolophosaurus_01 = module(...)\n\n-- PropTool uses GetRoot to build the inject the prefabs in ACSE\nMonolophosaurus_01.GetRoot = function()\n    -- Your prefab information goes in here\n    -- paste the data after the return keyword\n    return \n    {\n        Properties = {\n        MaterialPatternsName = {\n            Default = 'Monolophosaurus_PatternSet_01'\n        },\n        MaterialVariantsName = {\n            Default = 'Monolophosaurus_VariantSet_01'\n        },\n        AssetPackages = {\n            Default = {\n                __inheritance = 'Append'\n            }\n        },\n        MaterialPatternIndex = {\n            Default = 0\n        }\n    },\n    Components = {\n        Transform = {\n        }\n    },\n    Prefab = 'Monolophosaurus'\n    }\n\nend \n\n-- Relay on the current entity API to generate the complete prefab\nMonolophosaurus_01.GetFlattenedRoot = function()\n    local tPrefab = api.entity.CompilePrefab( Monolophosaurus_01.GetRoot(), 'Monolophosaurus_01')\n    return api.entity.FindPrefab('Monolophosaurus_01')\nend\n\nreturn Monolophosaurus_01\n</code></pre> <p>Assuming you followed this process, you should have already 3 new .lua files in your Main/ package folder. Now we need to load these prefabs, however; we want to make sure we add the prefabs in order. For this we have to look into the Prefab keyword usage inside the prefab definition: - Monolophosaurus_01 prefab has a line that says: Prefab = 'Monolophosaurus' - Monolophosaurus prefab has a chunk that says: DecalPrefabName = { Default = 'MonolophosaurusDinoFootPrint' }</p> <p>What this means is that Monolophosaurus_01 DEPENDS on Monolophosaurus, and Monolophosaurus DEPENDS on MonolophosaurusDinoFootPrint. Because of this dependecy tree, we need to load the prefabs in the inverse order:</p> <ul> <li>1st MonolophosaurusDinoFootPrint</li> <li>2nd Monolophosaurus</li> <li>3rd Monolophosaurus_01</li> </ul> <p>So back to the Database.YOURMODNAMEPrefabData.lua file, we will change everything inside it to this new format (Notice that the massive table of prefabs is no longer present in this file). Replace YOURMODNAME with the final mod name:</p> <p><pre><code>-----------------------------------------------------------------------\n-- @file   Database.YOURMODNAMEPrefabData.lua\n-- @author yourself\n--\n-- @brief  Injects the ACSE prefabs into the game\n-- @see    https://github.com/OpenNaja/ACSE\n-----------------------------------------------------------------------\nlocal global  = _G\nlocal require = global.require\n\n-- @package Database\n-- @class YOURMODNAMEPrefabData\nlocal YOURMODNAMEPrefabData= module(...)\n\nYOURMODNAMEPrefabData.AddLuaPrefabs = function(_fnAdd)\n    -- Use one line for each prefab, make sure they are in the right order.\n    _fnAdd('MonolophosaurusDinoFootPrint', require('MonolophosaurusDinoFootPrint').GetRoot())\n    _fnAdd('Monolophosaurus', require('Monolophosaurus').GetRoot())\n    _fnAdd('Monolophosaurus_01', require('Monolophosaurus_01').GetRoot())\nend\n</code></pre> After you've done all these changes, once you run the game there should not be any error compiling the prefabs. </p>"},{"location":"Guides/ACSE/Scripting-Guide/LuaDatabase-Prefabs/#species-viewer","title":"Species Viewer","text":"<p>IF you followed this process, you have already createst the PREFABNAME.lua file required for the Species viewer. Instead of this become an extra-step, we have reduced the chances of introducing a mistake into the game by having different game and species viewer prefabs.</p>"},{"location":"Guides/Audio/","title":"Audio","text":""},{"location":"Guides/Audio/#wwise-format","title":"Wwise Format","text":"<p>Useful reading on the format:</p> <ul> <li>wwiser Documentation</li> <li>Audiokinetic Wwise Tutorials</li> <li>Audiokinetic Wwise Documentation</li> </ul>"},{"location":"Guides/Audio/#extracting-audio","title":"Extracting Audio","text":"<p>Use BNK explorer in the BNK Tool to open the BNK file you want to edit. It shows the hierarchical structure of the BNK. You can extract or inject sounds. Event names are stored as hashes in the .bnk files, but we have built name tables to resolve a good amount of events back to their original name.</p>"},{"location":"Guides/Audio/#creating-wem-files","title":"Creating .wem Files","text":"<p>When editing audio files you must first install WWise. The files used by the game are .wem format which can be created from .wav files using WWise software.</p> <p>Once you have a .wav file you want to convert to .wem, follow this video tutorial: </p> <p>Converting Wav to Wem with WWise</p>"},{"location":"Guides/Plugin/","title":"Blender Plugin","text":"<p>Construction</p> <p>This page is currently under construction!</p> <p>Once installed, import and export operators are found in their respective menus.</p> <p>Blender 4.2+</p> <p>To avoid long waiting times for shader compilation, go to <code>Edit</code> &gt; <code>Preferences</code>, then change <code>System</code> &gt; <code>Memory &amp; Limits</code> &gt; <code>Max Shader Compilation Suprocesses</code> to nonzero, ideally your amount of CPU cores (e.g. 16).</p>"},{"location":"Guides/Plugin/Animations/","title":"Animations","text":"<p>The Cobra engine uses two different kinds of animation formats: <code>.manis</code> containers with <code>.mani</code> animations and <code>.banis</code> containers with <code>.bani</code> animations. Extracted from OVL, you get the <code>.manis</code> and <code>.banis</code>.</p>"},{"location":"Guides/Plugin/Animations/#manis","title":"Manis","text":"<p><code>.manis</code> animations are sampled across all frames for different bones and transform channels. They are generally used for advanced character animation that requires dynamics, constraints or blending between animations.</p>"},{"location":"Guides/Plugin/Animations/#import","title":"Import","text":"<p>Select a target armature you want to animate before importing a <code>.manis</code> file.</p> <p>Limitations</p> <ul> <li>Most anims are stored as compressed data, which must be decompressed before being imported.</li> <li>Not all anims decompress correctly. If an anim fails to decompress, you may see no keyframes at all or a distorted mess.</li> <li>When anims do decompress, single keyframes or whole channels may still show unexpected distortions.</li> <li>Decompression is fairly slow. Keep track on the progress by turning on Blender's console (Window &gt; Toggle System Console) before importing. If you have to import the same <code>.manis</code> repeatedly, consider using the Manis Editor to decompress it once and for all.</li> </ul> <p>IMPORTANT</p> <p>To import compressed animations, the <code>bitarray</code> Python module must be installed in Blender's bundled Python.</p> <ul> <li> <p>Running Blender with administrator privileges, you can press the red button in the tools' settings (Edit &gt; Preferences &gt; Addons &gt; Cobra Tools). Restart Blender after downloading.</p> <p></p> </li> <li> <p>If the automatic process fails, you can install the module manually:</p> <p>1) Open a command prompt (not power shell) with admin privileges in the following folder (your blender version may vary, of course): <code>C:\\Program Files\\Blender Foundation\\Blender 4.0\\4.0\\python\\bin</code></p> <p>2) In that prompt, run this command: <code>python.exe -m pip install bitarray</code></p> <p></p> </li> </ul>"},{"location":"Guides/Plugin/Animations/#export","title":"Export","text":"<p>Transforms in blender actions are stored relative to the armature, but absolute in <code>.manis</code>. As a result, <code>.manis</code> export must know which actions belong to which armature:</p> <ul> <li>If you have a single action per armature, setting it as the current action in the Action Editor is enough.</li> <li>To export multiple actions from an armature, stash them in the NLA Editor or the Action Editor.</li> </ul> <p>Gotchas</p> <ul> <li>Export does not read the keyframes directly, but samples the visual transforms across an action's frame range. </li> <li>Constraints are automatically baked. </li> <li>Bones are included as needed; bones that don't move during an action are automatically discarded.</li> </ul> <p>Limitations</p> <ul> <li>Export only produces uncompressed animations, which occupy a lot of disk space and RAM bandwidth in-game. The game uses compressed animations for almost everything.</li> <li>If you plan on editing only some animations of a <code>.manis</code>, insert the modified (= uncompressed) ones into the compressed <code>.manis</code> file using the Manis Editor.</li> </ul>"},{"location":"Guides/Plugin/Animations/#scaling","title":"Scaling","text":"<p>A command line script is provided to scale compressed animations and ms2 models by a given factor. Call it from a CMD or PowerShell window like this:</p> <p>CMD</p> <p><code>python resize_manis_cmd.py [FOLDER] [SCALE_FACTOR]</code></p> <p><code>python resize_manis_cmd.py \"C:\\Users\\USER\\Desktop\\tiger\" 1.4</code></p>"},{"location":"Guides/Plugin/Animations/#manis-editor","title":"Manis Editor","text":"<p>A GUI editor to manipulate <code>.manis</code> files.</p> <p></p> <p>Use Cases</p> <ul> <li>changing speed of anims</li> <li>decompressing anims</li> <li>renaming / deleting / appending anims</li> </ul>"},{"location":"Guides/Plugin/Animations/#banis","title":"Banis","text":"<p><code>.banis</code> animations hold rigidly sampled location and rotation keys for all bones in a model. They are generally used for simple building or character animations, such as:</p> <ul> <li>guests</li> <li>feeders</li> <li>exhibit animals</li> </ul> <p>Limitations</p> <p>The transforms used by <code>.banis</code> are currently not fully understood. Import is experimental and close to expected for some <code>.banis</code>, but totally broken for others. Export is not useable in production.</p>"},{"location":"Guides/Plugin/Models/","title":"Models","text":""},{"location":"Guides/Plugin/Models/#data-layout","title":"Data Layout","text":""},{"location":"Guides/Plugin/Models/#scene-structure","title":"Scene Structure","text":"<p>An MS2 file contains several MDL2 models. Each MS2 file is imported as a separate scene in Blender. Blender collections are used to represent separate MDL2s in an MS2. Each MDL2 has several sub-collections for LODs (..._L0, ..._L1, etc) and one for joints if applicable.</p>"},{"location":"Guides/Plugin/Models/#custom-panels","title":"Custom Panels","text":"<p>To accomodate all relevant data and provide easy access to various operators, several panels are added to blender's GUI. See the sections below for explanations of the operators and suggested workflows.</p>"},{"location":"Guides/Plugin/Models/#scene-panel","title":"Scene Panel","text":""},{"location":"Guides/Plugin/Models/#mdl2-panel","title":"MDL2 Panel","text":""},{"location":"Guides/Plugin/Models/#mesh-panel","title":"Mesh Panel","text":""},{"location":"Guides/Plugin/Models/#collision-panel","title":"Collision Panel","text":""},{"location":"Guides/Plugin/Models/#view-panel","title":"View Panel","text":""},{"location":"Guides/Plugin/Models/#lods","title":"LODs","text":"<p>Models usually have anywhere between 1 and 6 LODs. To make these easier to handle, we provide two utilities:</p> <ul> <li>Update LODs: automatically sets up the required collections and tries to decimate the poly count of the geometry. Note that decimation of meshes with many small elements such as spikes or teeth performs poorly, as they steal resolution from more important and bigger geometry.</li> <li>Current LOD: quickly switch between different LODs using this tool in 3D View's View panel.</li> </ul>"},{"location":"Guides/Plugin/Models/#hair","title":"Hair","text":"<p>The Cobra Engine uses the shells and fins technique to render realistic fur. Additionally, hair cards may be used for long strands of hair. Internally, a flow map is used to store the direction of the fur as vertex colors. As flow maps are not intuitive to edit, we provide tools to convert to and from blender's particle hair.</p> <p>See the relevant operators in the Mesh Panel. The custom properties are also known to affect the rendering of hair.</p>"},{"location":"Guides/Plugin/Models/#foliage","title":"Foliage","text":"<p>Foliage uses shape keys to blend between LOD levels.</p> <p>Tip</p> <p>Use the Current LOD button to preview the transitions between LODs smoothened by the shape keys.</p> <p>The last LOD often uses the impostor technique, which packs renders of the complete tree from various angles into a texture atlas. In-game, the best sprite for the current camera angle is drawn.</p> <p>Modified vertex normals are essential to create believable shading for foliage. Use blender's data transfer modifier to copy normals from a convex hull mesh onto the foliage alpha cards.</p>"},{"location":"Guides/Plugin/Models/#armature","title":"Armature","text":"<p>Cobra rigs are hierarchical and can be very complicated.</p> <p>Tip</p> <p>Some Cobra models lack an armature. If collision or interaction with the object is required, it must have an armature.</p>"},{"location":"Guides/Plugin/Models/#bones","title":"Bones","text":"<p>Bones are the basic building blocks of the rig. They can be animated and used for weight-painting meshes.</p> <p>Warning</p> <p>The mesh format only supports up to 255 bones, and up to 4 bones per vertex.</p> <p>Tip</p> <p>Use the rig editing features to adjust armatures without breaking animations.</p>"},{"location":"Guides/Plugin/Models/#joints","title":"Joints","text":"<p>Joints are represented by empties in blender. They are parented to armature bones. Usually, there is one joint per bone but there may be more for scenery.</p> <p>Joints can be animated to animate their colliders; they are not used in skeletal animation.</p>"},{"location":"Guides/Plugin/Models/#colliders","title":"Colliders","text":"<p>A joint can contain one or multiple colliders for physics simulations. Several types of colliders are supported:</p> <ul> <li>Sphere</li> <li>Box</li> <li>Cylinder</li> <li>Capsule</li> <li>Convex Hull</li> <li>Mesh Collision</li> </ul> <p>Warning</p> <p>Don't transform the primitive-based colliders (Sphere, Box, Cylinder, Capsule) in Edit Mode, only in Object Mode.</p> <p>You can adjust each collider's physics properties in the Collision Panel.</p>"},{"location":"Guides/Plugin/Models/#constraints","title":"Constraints","text":"<p>Construction</p> <p>This section is currently under construction!</p>"},{"location":"Guides/Textures/","title":"Textures","text":"<p>Construction</p> <p>This page is currently under construction!</p> <p>Once installed, import and export operators are found in their respective menus.</p> <p>Blender 4.2+</p> <p>To avoid long waiting times for shader compilation, go to <code>Edit</code> &gt; <code>Preferences</code>, then change <code>System</code> &gt; <code>Memory &amp; Limits</code> &gt; <code>Max Shader Compilation Suprocesses</code> to nonzero, ideally your amount of CPU cores (e.g. 16).</p>"},{"location":"Guides/Textures/Authoring%20Icons/","title":"Authoring Icons","text":"<p>Example of Compression Artifacts</p> <p>Note the blocky artifacts of wrong color along the outline.</p> <p></p> <p>While all textures should be creating with the final DDS container in mind, bad authoring is by far the most obvious on icons. This is caused by the combination of cutout PNG renders with alpha channel and the block compression used in most DDS formats. In a nutshell, block compression reduces the amount of colors per 4x4 pixel block down from the original 16 colors to two main and two interpolated colors. The result is usually close enough for opaque blocks as to not be too apparent.</p> <p>When the alpha channel is authored incorrectly, it throws off the color interpolation. By default, fully transparent pixel are exported as black color, so you waste color accuracy on the transparent pixels. The fix is to assign colors that are actually used in the 4x4 pixel block to all the transparent pixels.</p>"},{"location":"Guides/Textures/Authoring%20Icons/#prerequisites","title":"Prerequisites","text":"<p>Install Gmic for gimp.</p>"},{"location":"Guides/Textures/Authoring%20Icons/#authoring-instructions","title":"Authoring Instructions","text":"<ol> <li>Copy your source layer and use curves or filters (Filters &gt; Generic &gt; Erode) on its alpha mask to remove as much white haloing on the outline as possible. You may not need to do this with your original, e.g. if it is a render and doesn't have haloing.</li> <li>Copy the result layer from Step 1 through G-Mic's Solidify filter. </li> <li>Merge the result layer from Step 1 down onto the layer from Step 2. Without the alpha channel disabled, it should look like this: </li> <li>Replace the alpha mask for Step 3 with the original alpha.</li> <li>Use the PNG export option to preserve background color. </li> </ol>"},{"location":"Modding-FAQ/","title":"Modding FAQ","text":"<p>Construction</p> <p>This page is currently under construction!</p>"},{"location":"Modding-FAQ/Crash-Troubleshooting/","title":"Crash Troubleshooting","text":"<p>Construction</p> <p>This page is currently under construction!</p> <p>This document will cover various scenarios in which your game may crash, and provide possible solutions.</p> <p>This document assumes you are familiar with modding and are having trouble with your own mod.</p> <p>NON-MOD AUTHORS</p> <p>For end-user troubleshooting regarding your installed mods, instead refer to Installed Mods Troubleshooting</p>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#on-game-start","title":"On Game Start","text":""},{"location":"Modding-FAQ/Crash-Troubleshooting/#immediate-before-intro-cinematic","title":"Immediate (Before intro cinematic)","text":"<ol> <li> <p>Check your Lua file syntax. Lua syntax errors will show as Errors in OVL Tool upon injection</p> <p>Note</p> <p>You can also avoid syntax errors by using Visual Studio Code with a Lua extension.</p> </li> <li> <p>Check that the OVLs included by your OVLs exist. Included OVLs are at the bottom of OVL Tool in the dropdown menu</p> </li> <li>Check that all modded AssetPackages named in your Lua prefabs have an .assetpkg in Init.OVL</li> <li>Check that all used .assetpkg in Init.OVL reference an OVL that exists in ovldata</li> <li>Check that all FDB named in GetDatabaseConfig in your Databases Lua exist in Main.OVL</li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#just-before-globe-menu","title":"Just before globe menu","text":"<ol> <li>A functional error in your Lua code that is not caught with just syntax checking, i.e. missing functions, tables</li> <li>?</li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#on-map-load","title":"On Map Load","text":"Planet ZooJurassic World Evolution 2 <ol> <li>Check that your animal has an .animalresearchunlockssettings file<ul> <li>...and that the number of VetLevel in this file matches the Research FDB</li> <li>...and the names of the research in this file match the names in the Research FDB</li> </ul> </li> <li>?</li> </ol> <ol> <li>?</li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#in-game","title":"In-Game","text":""},{"location":"Modding-FAQ/Crash-Troubleshooting/#on-animal-spawn","title":"On Animal Spawn","text":"Planet ZooJurassic World Evolution 2 <ol> <li>Main.OVL Prefabs<ul> <li> The Visuals Prefab for the animal/gender exists in your Data Lua, or is <code>required</code> in Data/LuaDatabases as its own .lua<ul> <li> If using separate .lua per Visuals Prefab, ensure these exist in your OVL and are named the same as in your Data Lua</li> </ul> </li> <li> The Visuals Prefab is correctly spelled and capitalized according to the AnimalDefinitions table of the Animals FDB</li> <li> The modded AssetPackages referenced by the Visuals Prefab exist as .assetpkg in your Init.OVL</li> <li> The <code>ModelName</code>, <code>MotionGraphName</code>, and <code>HitcheckModel</code> strings all match the names of the MDL2 and motiongraph files in your animal OVL</li> </ul> </li> <li>Init.OVL Asset Packages<ul> <li> The .assetpkg match in name with the modded AssetPackages in your Visuals Prefabs</li> <li> The .assetpkg contents reference your Animal OVLs correctly i.e. <code>ovldata\\{MOD_NAME}\\Animals\\{ANIMAL_NAME}\\{ANIMAL_NAME}</code></li> </ul> </li> <li>Main.OVL FDBs<ul> <li> The Visuals Prefabs in the AnimalDefinitions table are spelled and capitalized the same as the Prefabs loaded by your Data Lua.</li> </ul> </li> </ol> <ol> <li>Main.OVL Prefabs<ul> <li> The Prefab for the Dinosaur exists in your Data Lua, or is <code>required</code> in Data/LuaDatabases as its own .lua<ul> <li> If using separate .lua per Prefab, ensure these exist in your OVL and are named the same as in your Data Lua</li> </ul> </li> <li> The Prefab is correctly spelled and capitalized according to the Species table of the Dinosaurs FDB</li> <li> The modded AssetPackages referenced by the Prefab exist as .assetpkg in your Init.OVL</li> <li> The <code>ModelName</code> and <code>MotionGraphName</code> strings all match the names of the MDL2 and motiongraph files in your Dinosaur OVL</li> <li> The <code>DecalPrefabName</code>, if modded, matches the name and capitalization of the Decal Prefabs loaded by your Data Lua.</li> <li> Any modded Prefabs (e.g. Footprint) referenced by your Dinosaur Prefab are listed before the Dinosaur Prefab in your Data Lua.</li> </ul> </li> <li>Init.OVL Asset Packages<ul> <li> The .assetpkg match in name with the modded AssetPackages in your Prefabs</li> <li> The .assetpkg contents reference your Dinosaur OVLs correctly i.e. <code>ovldata\\{MOD_NAME}\\Dinosaurs\\{DINO_NAME}\\{DINO_NAME}</code></li> </ul> </li> <li>Main.OVL FDBs<ul> <li> The Prefabs in the Species table are spelled and capitalized the same as the Prefabs loaded by your Data Lua.</li> <li> SpeciesID must be unique and not collide with any other Species</li> </ul> </li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#miscellaneous","title":"Miscellaneous","text":"Planet ZooJurassic World Evolution 2Planet Coaster"},{"location":"Modding-FAQ/Crash-Troubleshooting/#on-research-open","title":"On Research Open","text":"<ol> <li>Ensure the animal's Research FDB has been made with the tools/scripts. <ul> <li>Tool-made Research FDB ResearchIDs are taken care of for you, thus minimizing chances of ID collision crashes</li> </ul> </li> <li>?</li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#on-zoopedia-open-or-zoopedia-filteringscrolling","title":"On Zoopedia Open or Zoopedia Filtering/Scrolling","text":"<ol> <li>Check the references in your Zoopedia-related .userinterfaceicondata <ul> <li>Check that the .assetpkg referenced exists</li> </ul> </li> <li>?</li> </ol>"},{"location":"Modding-FAQ/Crash-Troubleshooting/#something-jwe2","title":"Something JWE2","text":""},{"location":"Modding-FAQ/Crash-Troubleshooting/#something-pc","title":"Something PC","text":""},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/","title":"Installed Mods Troubleshooting","text":""},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#before-installing-mods","title":"Before Installing Mods","text":"<p>Warning</p> <p>Removing, installing, or updating mods comes with the risk of having issues with loading old parks. If there is a park you are working on and you do not want to deal with the associated risks, do not modify your game.</p> <ol> <li>Save a backup of your current ovldata folder so that you can always go back to the version of the game that can load your existing parks.</li> <li>Make a copy of your save files.</li> </ol>"},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#when-installing-mods","title":"When Installing Mods","text":"<p>Mods interact with the game and other mods in different ways. Mods may:</p> <ol> <li>Require other mods to work (e.g. it requires ACSE).</li> <li>Require specific DLCs to be owned before they can work, because it requires features from this DLC.</li> <li>Manipulate game data used by other mods, or even manipulate other mod data (e.g. PZPlus).</li> </ol> <p>Thus, it is important to read the Nexus Mods page description of the mod you are downloading to understand what you need to do for the mod to work correctly.</p> <p>MODPOCALYPSE</p> <p>It is NOT RECOMMENDED to install several mods at once, especially new mods you have never used before. If one of them crashes the game, you'll have no idea which one of them is the culprit. </p> <p>INSTEAD...</p> <p>Install new mods one by one, and always make sure you download the latest version of the mod.</p>"},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#installing-the-mod","title":"Installing the Mod","text":"<p>The ovldata folder is where the game reads its Content Packs. Every mod nowadays is a ContentPack and has to be installed the same way as the game installs its DLCs in this folder. Do not make folders and subfolders and put mods in them, this will break the game. Every mod needs to be installed in the same folder.  Mod folder names don't usually have sequences of numbers or other characters, just letters (and maybe a number or two). If you see a folder that has a long sequence of numbers on it you need to install the mod correctly.</p> <p>Every mod needs a 'manifest' file. You will find this file Inside every folder in OvlData. If you go to the mod folder and you can't find a file named 'Manifest' chances are this mod is installed wrong.</p>"},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#crashes-after-installation","title":"Crashes After Installation","text":"<p>If you install a mod and it crashes your game, check the installation instructions and requirements.  When things don't work, the best course of action is to remove the last mod you installed and try running the game again. If this mod keeps crashing your game you might want to open a bug report in Nexus Mods commenting on the problem.</p> <p>Construction</p> <p>The area below is under construction!</p>"},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#if-all-mods-are-crashing-or-mods-dont-work-for-you","title":"if all mods are crashing or mods don't work for you","text":"<p>Usually this is a misconception and more like a rare case. Most likely you have reached a point where your game is completely unstable and will be like that even without mods. Here is a little troubleshooting guide to get you through this case:</p> <ol> <li>Make sure you make a copy of your saved games, you might want to come back to them (TODO: maybe add the point)</li> <li>Remove all mods and try running the game. if the game doesn't run, then Validate the game files (TODO: maybe add how to). If this is still not working, reinstall the game. It might be a problem somewhere else in the computer that has nothing to do with the game.</li> <li>You need to make sure that the game runs without mods, and confirm that by going to the globe screen (main menu).</li> <li>Install ACSE (and only ACSE). Don't rush installing mods again. ACSE will show its version in the main menu screen (globe screen), confirm ACSE is running before installing other mods.</li> <li>Install PZP (and only PZP). Again, PZP will show its version in the globe screen, you can confirm it is working when you go to the main menu.</li> <li>Start installing mods again, but remember that to get different results you need to do something different this time. Redownload all the mods you are going to install. This process might look daunting but the current mods you had downloaded broke your game, and installing them might just have the same ending results. This also ensures you always have the latest versions and not old ones. Do not install all the mods at once, install them in packs of 5 or 10 (or less), so you know which ones you have to remove if the game stops working.</li> <li>From this point, if you encounter a problem with a mod, it will most likely be a mod issue that you'd need to report in the corresponding Nexus Mods page.</li> </ol>"},{"location":"Modding-FAQ/Installed-Mods-Troubleshooting/#other-tips","title":"Other tips","text":"<p>When you want to preserve a park, it is important to know that you will most likely need the same mods installed the next time you want to open it. Either take notes or make a copy of your game files just in case so you will always have a list of the mods you used, or even the mod versions that worked when you were making the park.</p>"},{"location":"Tools-FAQ/","title":"Tools FAQ","text":"<p>Construction</p> <p>This page is currently under construction!</p> <p>For game-specific issues, please see Modding FAQ</p> <p>Where is the latest release?</p> <p>Download </p> <p>I do not know where the log file is.</p> <ul> <li> <p>For Blender, the file is located in</p> <p><code>C:\\Users\\USERNAME(1)\\AppData\\Roaming\\Blender Foundation\\Blender\\4.0(2)\\scripts\\addons\\cobra-tools-master\\blender_plugin.log</code></p> <ol> <li>Your Windows username</li> <li>Your version of Blender, e.g. 4.0</li> </ol> </li> <li> <p>For OVL Tool, FGM Editor, MS2 Tool, Mod Tool, the log file is located next to the .py you open the tool with, with the same name.</p> </li> </ul> <p>The tools immediately close after opening.</p> <ol> <li>Ensure you have at least Python 3.11</li> <li>Ensure you have all Python dependencies.</li> <li>Do not run the tools from the ZIP file. Extract the folder instead.</li> <li>If you have multiple version of Python installed, consider removing the other ones (if possible), or associate the cobra-tools .py files with the correct version of Python.</li> </ol> <p>Q: I receive an error on injecting a file.Q: When I import an MS2 into Blender, there is an error and the scene is blank.Q: My Blender plugin will not open the files I extract, or my tools will not inject the MS2 I export.</p> <ol> <li>Ensure your Blender plugin version is the same as your tools version.</li> <li>Ensure your file is not an older, outdated extraction. Re-extract the file with the latest tools.</li> <li>If the file is freshly extracted and the plugin/tool versions do not mismatch, report the error with the full log file in #cobra-tools-help</li> </ol>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/04/02/Welcome/","title":"Welcome","text":"<p>\ud83c\udf89 Welcome to our new site for Cobra Tools! \ud83c\udf89</p> <p>As well as providing easier navigation and steps for downloading, installing, and updating the tools, this new site will continue to be expanded with FAQs, modding guides, troubleshooting guides, and more. Some of these are present already, but still under construction. You can check them out in the navigation above. </p> <p>We have also created a  Trello with several boards for better user-facing progress tracking on tool and modding developments. Please check it out!</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/","title":"OpenNaja Announcement","text":"<p>\ud83d\udce2 Server Announcement: Important Updates and Changes Ahead! \ud83d\udce2</p> <p>Hello, Open Naja Modding Community!</p> <p>We hope you're all doing well and creating amazing mods. We're reaching out today with some important updates and changes to our server that we believe will help foster a more supportive and productive environment for all our members.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#team-changes","title":"Team Changes","text":"<p>First, we want to extend our gratitude to our moderation team for their contributions. As our modding community continues to thrive, we're taking this opportunity to refresh our team structure to ensure we're providing the best possible support for everyone. Due to time constraints from his many other committments, Leaf will no longer be acting as Community Manager or Moderator. In keeping with our focus on optimizing the team for community growth, you may also notice some other changes in team member roles.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#open-call-for-moderators","title":"Open Call for Moderators","text":"<p>With these changes, we're on the lookout for passionate, dedicated individuals to join our moderation team. If you have a love for modding, a desire to help others, and a commitment to maintaining a positive community, we'd love to hear from you. Please reach out to me with express intent to apply.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#website-updates","title":"Website Updates","text":"<p>New Landing Page! We have been working hard on our new github.io page. As well as providing easier navigation and steps for downloading, installing, and updating the tools, this new site will continue to be expanded with FAQs, modding guides, troubleshooting guides, and more.</p> <p>New Trello! To better publicize Cobra Tools and ACSE development, as well as new kinds of tools and mods being prototyped by the developers, we have created a Trello to put all of this in one easy to view place. </p> <ul> <li> Cobra Tools: This board tracks some of the things coming to Cobra Tools, as GitHub Issues and Projects lack user-friendly views.</li> <li> PZ Meta Wishlist: This board tracks Free Update Meta-Wishlist items being considered and worked on by the devs.</li> <li> ACSE Corp Research Lab: This board tracks the progress of new ACSE features, and major new additions, mechanics, and overhauls for Frontier games.</li> <li> PZPlus Expansions: This board tracks the progress of various sub-mods for PZPlus, with a focus on remastering and expanding neglected parts of the game.</li> </ul>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#channel-updates","title":"Channel Updates","text":"<p>Following positive feedback from the JWE modding channel, we are reverting the PZ modding channel back to being accessible for modders only. This change aims to create a more focused environment for mod discussion and development. Those with Certified Modder role will retain access. Aspiring modders without the role yet can still receive modding help in  modding-help-pz and  modding-help-jwe2.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#new-post-guidelines","title":"New Post Guidelines","text":"<p>To ensure our new members find the help and resources they need efficiently, we've improved our Post Guidelines in  modding-help-pz and  modding-help-jwe2. These guidelines will better direct questions and discussions to the appropriate channels, making it easier for everyone to get the support they need.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#new-modding-guidelines","title":"New Modding Guidelines","text":"<p>We believe in upholding a creative modding environment where everyone feels empowered to mod whatever inspires them, regardless of existing mod releases. Collaborating to improve existing mods is welcome, but pressuring others to do so or discouraging others' efforts to release their own version is strictly prohibited.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#new-commissioning-guidelines","title":"New Commissioning Guidelines","text":"<p>We have instituted new rules for commissions clarifying and expanding the requirements for using a third party's work, as well as making explicit that mod updates must follow the same monetization rules as mod releases. Please refer to  rules, Rule 9.</p> <p>These new rules align well with the existing rules against paywalled, time-gated, and exclusive/private-use commissions. This is done in an effort to foster improved community health and to prevent others' work from being used without permission to make a profit.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#new-commission-request-boards","title":"New Commission Request Boards","text":"<p>We are implementing commission request channels for each game, providing more visibility to modders on what commissions are available to take on. </p> <ul> <li>Get Your Mod Commission Seen! Post your request in the game's commission board clearly outlining the commission details to attract the right modder for the job.</li> <li>Team Up for Bigger Projects. Team up with up to four others to pool resources and collectively request the mod. Five members is a suggested maximum to minimize micromanagement and decrease the likeilhood of dropouts. Highly motivated individuals and willing modders may exceed this at their discretion.</li> <li>Find Your Modding Match! Modders may DM you or respond to the post to express interest in taking the commission on. You are then encouraged to reach out to interested modders to come to an agreement. Once a modder has been selected, simply make an update stating who you chose and close the topic.</li> <li>Private Negotiation Avoids Public Bidding Wars. Please take note that members and modders alike need not publicize the negotiations over pricing and contracts. Such things are ultimately a private negotiation between both parties.</li> </ul>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#developer-support","title":"Developer Support","text":"<p>There have been new rules instituted regarding developer support. Please refer to  rules, Rule 11.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#revamped-rules","title":"Revamped Rules","text":"<p>Our  rules have been revamped to improve legibility, and updated to include stray rules from other locations such as  announcements. In addition to these improvements, there have also been other minor updates. We recommend everyone revisit the rules in full to ensure they are familiar with the latest updates.</p>"},{"location":"blog/2024/04/09/OpenNaja-Announcement/#conclusion","title":"Conclusion","text":"<p>We believe these changes will help our community grow stronger, more cohesive, and more creative. Your feedback is invaluable to us, so please don't hesitate to share your thoughts and suggestions with me or other staff.</p> <p>Thank you all for your continued support and dedication to modding. Let's keep creating, sharing, and inspiring each other.</p> <p>Happy Modding!</p> <p>\ud83d\udee0\ufe0f The Open Naja Development Team \ud83d\udee0\ufe0f</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/news/","title":"News","text":""},{"location":"blog/category/discord-announcements/","title":"Discord Announcements","text":""},{"location":"blog/category/site-updates/","title":"Site Updates","text":""}]}